syntax = "proto3";

package spec_oracle;

service SpecOracle {
  // Node operations
  rpc AddNode(AddNodeRequest) returns (AddNodeResponse);
  rpc GetNode(GetNodeRequest) returns (GetNodeResponse);
  rpc ListNodes(ListNodesRequest) returns (ListNodesResponse);
  rpc RemoveNode(RemoveNodeRequest) returns (RemoveNodeResponse);

  // Edge operations
  rpc AddEdge(AddEdgeRequest) returns (AddEdgeResponse);
  rpc ListEdges(ListEdgesRequest) returns (ListEdgesResponse);
  rpc RemoveEdge(RemoveEdgeRequest) returns (RemoveEdgeResponse);

  // Query and analysis
  rpc Query(QueryRequest) returns (QueryResponse);
  rpc DetectContradictions(DetectContradictionsRequest) returns (DetectContradictionsResponse);
  rpc DetectOmissions(DetectOmissionsRequest) returns (DetectOmissionsResponse);
  rpc DetectLayerInconsistencies(DetectLayerInconsistenciesRequest) returns (DetectLayerInconsistenciesResponse);

  // Terminology resolution
  rpc ResolveTerminology(ResolveTerminologyRequest) returns (ResolveTerminologyResponse);

  // Layer-aware operations
  rpc FilterByLayer(FilterByLayerRequest) returns (FilterByLayerResponse);
  rpc FindFormalizations(FindFormalizationsRequest) returns (FindFormalizationsResponse);

  // Semantic normalization
  rpc FindRelatedTerms(FindRelatedTermsRequest) returns (FindRelatedTermsResponse);
  rpc DetectPotentialSynonyms(DetectPotentialSynonymsRequest) returns (DetectPotentialSynonymsResponse);

  // Executable contracts
  rpc GenerateContractTemplate(GenerateContractTemplateRequest) returns (GenerateContractTemplateResponse);
  rpc GetTestCoverage(GetTestCoverageRequest) returns (GetTestCoverageResponse);

  // Graded compliance
  rpc CalculateCompliance(CalculateComplianceRequest) returns (CalculateComplianceResponse);
  rpc GetComplianceReport(GetComplianceReportRequest) returns (GetComplianceReportResponse);
}

// --- Node types ---

message SpecNode {
  string id = 1;
  string content = 2;
  SpecNodeKind kind = 3;
  map<string, string> metadata = 4;
  int64 created_at = 5;
  int64 modified_at = 6;
  uint32 formality_layer = 7;  // 0=natural, 1=structured, 2=formal, 3=executable
}

enum SpecNodeKind {
  SPEC_NODE_KIND_UNSPECIFIED = 0;
  ASSERTION = 1;       // A concrete claim about behavior
  CONSTRAINT = 2;      // A universal constraint (invariant)
  SCENARIO = 3;        // An existential requirement (a path that must exist)
  DEFINITION = 4;      // A term definition
  DOMAIN = 5;          // A domain boundary declaration
}

// --- Edge types ---

message SpecEdge {
  string id = 1;
  string source_id = 2;
  string target_id = 3;
  SpecEdgeKind kind = 4;
  map<string, string> metadata = 5;
  int64 created_at = 6;
}

enum SpecEdgeKind {
  SPEC_EDGE_KIND_UNSPECIFIED = 0;
  REFINES = 1;         // Target refines source (is more specific)
  DEPENDS_ON = 2;      // Source depends on target
  CONTRADICTS = 3;     // Source contradicts target
  DERIVES_FROM = 4;    // Source is derived from target
  SYNONYM = 5;         // Source and target are synonymous terms
  COMPOSES = 6;        // Source composes with target into a higher-level spec
  FORMALIZES = 7;      // Target is a more formal version of source
}

// --- Request/Response messages ---

message AddNodeRequest {
  string content = 1;
  SpecNodeKind kind = 2;
  map<string, string> metadata = 3;
}

message AddNodeResponse {
  SpecNode node = 1;
}

message GetNodeRequest {
  string id = 1;
}

message GetNodeResponse {
  SpecNode node = 1;
}

message ListNodesRequest {
  SpecNodeKind kind_filter = 1;  // 0 = no filter
}

message ListNodesResponse {
  repeated SpecNode nodes = 1;
}

message RemoveNodeRequest {
  string id = 1;
}

message RemoveNodeResponse {}

message AddEdgeRequest {
  string source_id = 1;
  string target_id = 2;
  SpecEdgeKind kind = 3;
  map<string, string> metadata = 4;
}

message AddEdgeResponse {
  SpecEdge edge = 1;
}

message ListEdgesRequest {
  string node_id = 1;  // empty = list all
}

message ListEdgesResponse {
  repeated SpecEdge edges = 1;
}

message RemoveEdgeRequest {
  string id = 1;
}

message RemoveEdgeResponse {}

message QueryRequest {
  string natural_language_query = 1;
}

message QueryResponse {
  repeated SpecNode matching_nodes = 1;
  string explanation = 2;
}

message DetectContradictionsRequest {}

message DetectContradictionsResponse {
  repeated Contradiction contradictions = 1;
}

message Contradiction {
  SpecNode node_a = 1;
  SpecNode node_b = 2;
  string explanation = 3;
}

message DetectOmissionsRequest {}

message DetectOmissionsResponse {
  repeated Omission omissions = 1;
}

message Omission {
  string description = 1;
  repeated SpecNode related_nodes = 2;
}

message ResolveTerminologyRequest {
  string term = 1;
}

message ResolveTerminologyResponse {
  repeated SpecNode definitions = 1;
  repeated string synonyms = 2;
}

message DetectLayerInconsistenciesRequest {}

message DetectLayerInconsistenciesResponse {
  repeated LayerInconsistency inconsistencies = 1;
}

message LayerInconsistency {
  SpecNode source = 1;
  SpecNode target = 2;
  string explanation = 3;
}

message FilterByLayerRequest {
  uint32 min_layer = 1;
  uint32 max_layer = 2;
}

message FilterByLayerResponse {
  repeated SpecNode nodes = 1;
}

message FindFormalizationsRequest {
  string node_id = 1;
}

message FindFormalizationsResponse {
  repeated SpecNode formalizations = 1;
  repeated SpecNode natural_sources = 2;
}

message FindRelatedTermsRequest {
  string term = 1;
  uint32 max_results = 2;  // 0 = no limit
}

message FindRelatedTermsResponse {
  repeated ScoredNode nodes = 1;
}

message ScoredNode {
  SpecNode node = 1;
  float score = 2;  // Similarity score 0.0-1.0
}

message DetectPotentialSynonymsRequest {
  float min_similarity = 1;  // Minimum similarity threshold (default 0.3)
}

message DetectPotentialSynonymsResponse {
  repeated SynonymCandidate candidates = 1;
}

message SynonymCandidate {
  SpecNode node_a = 1;
  SpecNode node_b = 2;
  float similarity = 3;
}

message GenerateContractTemplateRequest {
  string node_id = 1;
  string language = 2;  // Target language: "rust", "python", etc.
}

message GenerateContractTemplateResponse {
  string template = 1;  // Generated test template code
  string node_kind = 2;  // "constraint" or "scenario"
}

message GetTestCoverageRequest {}

message GetTestCoverageResponse {
  uint32 total_testable = 1;       // Total constraints + scenarios
  uint32 with_tests = 2;            // Nodes with test_file metadata
  float coverage_ratio = 3;         // Ratio 0.0-1.0
  repeated SpecNode nodes_with_tests = 4;
  repeated SpecNode nodes_without_tests = 5;
}

message CalculateComplianceRequest {
  string node_id = 1;   // Specification node ID
  string code = 2;      // Code snippet to check compliance against
}

message CalculateComplianceResponse {
  float score = 1;              // Overall compliance score 0.0-1.0
  float keyword_overlap = 2;    // Semantic keyword similarity
  float structural_match = 3;   // Structural pattern matching
  string explanation = 4;       // Human-readable explanation
}

message GetComplianceReportRequest {}

message GetComplianceReportResponse {
  repeated ComplianceEntry entries = 1;
}

message ComplianceEntry {
  SpecNode node = 1;
  float score = 2;
  float keyword_overlap = 3;
  float structural_match = 4;
  string explanation = 5;
}
