# Motivation: なぜspecORACLEが必要なのか

## 問題提起：多層防御の統制困難性

現代のソフトウェア開発では、実装の正しさを保証するために多層防御が不可欠です。しかし、各層が独立して進化すると、**全体としての一貫性・整合性を保つことが極めて困難**になります。

### 多層防御の現実

例えば、ztd-query-phpプロジェクトを見ると、以下のような多層的な保証が行われています：

- **契約（Design by Contract）**: 事前条件・事後条件・不変条件
- **性質検査（Property-Based Testing）**: ランダム入力での性質検証
- **テスト（Unit/Integration/E2E）**: 具体的な挙動の確認
- **型システム**: 静的な型安全性
- **Schema検証**: データ構造の妥当性

さらに、広くソフトウェア開発全体を見渡せば：

- **VRT（Visual Regression Testing）**: UI の視覚的な正しさ
- **DB Contract**: データベーススキーマの契約
- **Consumer-Based Contract Testing**: マイクロサービス間の契約
- **形式手法（Lean4、Alloy、TLA+）**: 数学的証明

これらは**それぞれが正しい**ことを保証できます。しかし、**各層にフォーカスして進めると、全体として問題が出る**のです。

### 統制の失敗例

具体的な問題：

1. **層間の矛盾**:
   - E2Eテストは「パスワードは8文字以上」を検証
   - 型システムは`String`のみを保証（長さ制約なし）
   - ドキュメントには「10文字以上推奨」と記載
   - **どれが正しいのか？**

2. **保証の隙間**:
   - ユニットテストは個別関数の正しさを保証
   - E2Eテストはシナリオの正しさを保証
   - しかし、その間の層（統合の正しさ）が抜け落ちる

3. **変更の波及**:
   - 要求仕様が変更されても、全層に反映されない
   - 一部の層だけ更新され、他の層は古いまま
   - 結果として、全体の一貫性が失われる

## 仕様の多層性：各層の役割と限界

仕様は本質的に**多層構造**を持ちます。これは避けられない性質です。

### 層の例

- **U0（自然言語要求仕様）**: 「ユーザーは安全にログインできる」
- **U1（形式仕様）**: TLA+、Alloyによるモデル
- **U2（インターフェース仕様）**: gRPC proto、API仕様、型定義
- **U3（実装仕様）**: コード、テスト、契約、性質

各層は**異なる抽象度**で仕様を表現します。より上位の層は抽象的で、下位の層は具体的です。

### 単一手法の限界

重要な洞察：**単一の手法では、すべてを保証できない**

- 形式手法は数学的に正しさを証明できるが、すべてをモデル化するのは現実的ではない
- テストは具体的な挙動を確認できるが、すべてのケースを網羅できない
- 型システムは静的に安全性を保証できるが、動的な性質（「8文字以上」など）は表現できない

だからこそ、**多層防御**が必要です。各層が異なる側面を保証し、組み合わせることで全体を保証します。

## 根の部分の仕様：定義できないが存在する基盤

多層防御の根底には、**根の部分の仕様**があります。これは：

- **実際には定義できない**：完全に形式化・言語化することは不可能
- **しかし確かに存在する**：「このシステムはこうあるべき」という本質的な意図
- **すべての層の源泉**：各層の仕様は、この根から派生している

### 写像としての仕様群

実際にspec/specdで定義できるのは、**根の部分の仕様の荒めの写像**です：

```
[定義不可能な根の仕様]
        ↓ 写像（projection）
[spec/specdで管理する仕様群]
        ↓ 具体化（refinement）
[各層の実装・テスト・証明]
```

この「荒めの写像の仕様群」は：

- 完全ではない（根を完全に表現できない）
- しかし十分に有用（統制のための基準として機能する）
- 多少の曖昧さを許容する（厳密すぎると書けない）

## spec/specdの役割：統制を保つ基準

spec/specdは、**多層防御の統制を保つための基準**として機能します。

### 統制の仕組み

1. **共通の参照点**:
   - すべての層が参照すべき「基準となる仕様」
   - 層間の矛盾を検出できる
   - 変更の影響範囲を追跡できる

2. **一貫性の検証**:
   - U0の要求仕様とU3のテストが整合しているか？
   - 各層が同じ「根の仕様」から派生しているか？
   - 変更がすべての層に反映されているか？

3. **統制の可視化**:
   - どの仕様がどの層で保証されているか
   - どこに隙間があるか（保証されていない仕様）
   - どこに矛盾があるか（層間の不整合）

### なぜ「荒め」で良いのか

厳密な形式仕様を全体に適用するのは現実的ではありません。だからこそ：

- **多少粗くても、1つの基準になる仕様があれば統制を保てる**
- 完璧でなくても、方向性を示すだけで十分に価値がある
- 各層はこの基準を参照しながら、それぞれの方法で詳細化・保証する

## 理論的背景：仕様とは何か

この考え方の理論的基盤は、`docs/conversation.md`に詳しく記録されています。

### 主要な概念

**U（宇宙）、D（対象領域）、A（許容集合）、f（変換関数）**:

- **宇宙（Universe, U）**: 仕様が定義される全集合空間
- **対象領域（Domain, D）**: 仕様が実際に規定する領域
- **許容集合（Admissible set, A）**: 仕様が許容する実装の集合
- **変換関数（f）**: 層間の写像（U0からU1へ、U1からU2へ、など）

### 多層宇宙モデル

仕様は単一の宇宙ではなく、**複数の宇宙の合成**として理解されます：

```
U0（自然言語）──f0→ U1（形式仕様）──f1→ U2（インターフェース）──f2→ U3（実装）
```

各宇宙は独立した「許容集合」を持ち、変換関数fによって接続されます。

### 仕様の本質

- 仕様は「許容集合」である（何が正しいかを規定する）
- 完全性は達成不可能（すべてを定義することはできない）
- だからこそ、**統制のための基準**が必要

詳細は`docs/conversation.md`を参照してください。仕様の意味論、漏れ・矛盾の定義、多層構造の理論などが深く議論されています。

## 結論：specORACLEの存在意義

specORACLEは、以下を実現するために存在します：

1. **多層防御の統制**: 各層が独立して進化しても、一貫性を保つ
2. **基準となる仕様の管理**: 荒めでも、方向性を示す共通参照点
3. **層間の写像の追跡**: U0からU3への変換を可視化・検証
4. **矛盾と漏れの検出**: 全体としての問題を早期発見
5. **変更の影響分析**: 仕様変更がどの層に影響するかを追跡

**「単一の手法では保証できない」からこそ、多層防御が必要であり、「多層防御は統制が困難」からこそ、specORACLEのような統制ツールが必要なのです。**
