# テスト駆動仕様・振る舞い仕様

## 1. TDD（テスト駆動開発）における仕様としてのテスト

### 概要と歴史

テスト駆動開発（TDD）は、Kent Beckが1990年代後半にExtreme Programming（XP）の一部として体系化した開発手法である。「Red-Green-Refactor」のサイクル、すなわち（1）失敗するテストを書く、（2）テストを通す最小限のコードを書く、（3）リファクタリングする、という3段階を繰り返す。

TDDの本質的な洞察は、テストが検証（validation）ではなく仕様（specification）として機能するという点にある。テストを先に書くことで、開発者は実装の前にインターフェースと期待される振る舞いを定義する。Beck自身が「Canon TDD」で述べているように、テストの記述には2つの側面がある。振る舞いがどのように呼び出されるか（インターフェース設計）と、システムがその振る舞いをどう実装するか（実装設計）である。この二面性こそがテストと仕様の二重性（duality）の核心である。

### テストと仕様の二重性

テストは「動作する仕様書」として機能する。従来の仕様書が自然言語で要件を記述するのに対し、TDDのテストは実行可能なコードとして仕様を表現する。この二重性には以下の利点がある：

- **曖昧さの排除**: コードは自然言語と異なり解釈の余地がない
- **即座の検証**: 仕様と実装の一致を自動的に確認できる
- **設計の駆動**: テストを書く行為がインターフェース設計を促進する
- **回帰防止**: 仕様書として残りつつ、変更に対する安全網となる

## 2. BDD（振る舞い駆動開発）

### Dan Northとその起源

BDD（Behaviour-Driven Development）は、2003年にDaniel Terhorst-North（Dan North）がThoughtWorksで開発中に生まれた手法である。TDDを実践する際の「どこからテストを始めるか」「何をテストすべきか」「テストに何と名付けるか」という疑問に対する回答として考案された。

Northは最初にJUnitの代替としてJBehaveを開発し、「テスト」という語彙を「振る舞い」に置き換えた。これにより、開発者の思考がテストの技術的側面から、システムの振る舞いという仕様的側面に移行した。

### Given-When-Thenテンプレート

BDDの中核的な貢献は、Eric EvansのDDD（ドメイン駆動設計）におけるユビキタス言語の概念に影響を受けた「Given-When-Then」テンプレートである：

- **Given**（前提条件）: システムの初期状態を記述する
- **When**（アクション）: ユーザーまたはシステムの操作を記述する
- **Then**（期待結果）: 期待される結果を記述する

このテンプレートにより、ビジネス関係者と開発者が共通の言語で仕様を議論できるようになった。

## 3. Gherkin言語とCucumber/SpecFlow

### Gherkin言語

2007年にDan Northが導入したGherkinは、BDDの仕様を構造化するためのドメイン固有言語（DSL）である。ビジネスが読める言語として設計され、実装の詳細に踏み込まずにビジネスの振る舞いを記述できる。

主要キーワードは以下の通り：

| キーワード | 役割 |
|-----------|------|
| Feature | 機能の説明 |
| Scenario | 具体的なシナリオ |
| Given | 前提条件 |
| When | アクション |
| Then | 期待結果 |
| And / But | 条件の追加 |
| Scenario Outline | パラメータ化シナリオ |
| Examples | データテーブル |

Gherkinは多言語対応しており、日本語を含む多数の言語でキーワードを記述できる。

### Cucumber と SpecFlow

**Cucumber** はGherkin言語で記述された仕様を実行可能なテストとして実行するフレームワークである。Ruby、Java、JavaScript等の多言語をサポートする。2008年にAslak Hellesoyによって開発され、BDDツールの事実上の標準となった。

**SpecFlow** は.NETプラットフォーム向けのBDDフレームワークで、CucumberのGherkin構文を使用する。C#と統合され、Visual StudioやRiderとのIDE連携が充実している。

## 4. ATDD（受け入れテスト駆動開発）とFitNesse

### ATDDの概念

ATDD（Acceptance Test-Driven Development）は、ビジネス顧客・開発者・テスターの間のコミュニケーションに基づく開発手法である。「Story Test Driven Development（SDD）」や「Specification by Example」とも呼ばれる。

ATDDのサイクルは4段階で構成される：

1. **Discuss（議論）**: ステークホルダーと要件を議論する
2. **Distill（蒸留）**: 受け入れ基準を具体的なテストに落とし込む
3. **Develop（開発）**: テストを満たすコードを実装する
4. **Demo（デモ）**: 完成した機能をステークホルダーに示す

### FitNesse

FitNesseは、Wikiベースの受け入れテストフレームワークである。Webサーバー、Wiki、自動テストフレームワークを統合し、非技術者でも理解できる表形式でテストケースを記述できる。テストケースはWikiページとして階層構造で管理され、FITクライアントまたはSLiMクライアントで実行される。

## 5. Property-Based Testing

### QuickCheckの革新

1999年にHaskell向けに開発されたQuickCheckは、Property-Based Testing（性質ベーステスト）の先駆けである。従来のテストが個別の入出力ペアを検証するのに対し、Property-Based Testingは関数が満たすべき性質（プロパティ）を宣言し、フレームワークがランダムな入力を自動生成して性質の違反を探索する。

重要な機能として **Shrinking（縮小）** がある。反例が見つかった場合、それを最小限の失敗ケースに自動的に縮小することで、デバッグを容易にする。

### 主要ツールの比較

| ツール | 言語 | 特徴 |
|--------|------|------|
| QuickCheck | Haskell | 元祖、型クラスベースのジェネレータ |
| Hypothesis | Python | 最も拡張性が高い、stateful testing対応 |
| fast-check | JavaScript/TypeScript | Web開発向け、非同期対応 |
| FsCheck | F#/C# | .NET向け、QuickCheckの移植 |
| Hedgehog | Haskell | 統合的な shrinking |

### 仕様との関係

Property-Based Testingは仕様駆動開発との親和性が高い。仕様要件は多くの場合、直接的に性質として表現できるためである。例えば「ソート関数の出力は入力と同じ要素を持ち、昇順に並ぶ」という仕様は、そのままプロパティテストとして記述できる。

## 6. Specification by Example

### Gojko Adzicの手法

Gojko Adzicが体系化した「Specification by Example」は、具体的な例を使って仕様を記述する手法である。2011年の同名著書で世界中のチームへのインタビューに基づき、成功パターンを整理した。

主要な原則：

- **具体的な例で仕様を表現**: 抽象的な要件ではなく、具体的なシナリオで仕様を記述する
- **協調的な仕様策定**: ビジネス・開発・テストの三者で例を作成する
- **仕様の自動化**: 例をそのまま自動テストとして実行可能にする
- **生きたドキュメント**: テストの実行結果がドキュメントの正確性を保証する

## 7. 実行可能仕様と関連ツール

### 実行可能仕様の概念

実行可能仕様（Executable Specifications）とは、単なるドキュメントではなく、自動実行してシステムとの整合性を検証できる仕様である。仕様書が常にコードの実態と一致することを保証する。

### Concordion

ConcordionはHTMLベースの受け入れテストフレームワークである。自由形式のHTMLで仕様を記述でき、それをWebサイトとして公開可能である。Gherkinの構造化されたフォーマットとは対照的に、自然な文章で仕様を書ける点が特徴である。

### Gauge

ThoughtWorksが開発したGaugeは、Markdown形式で仕様を記述できるテストフレームワークである。プラグインアーキテクチャにより多言語をサポートし、仕様ドキュメントを自動生成する機能を持つ。

## 8. Living Documentation（生きたドキュメント）

生きたドキュメント（Living Documentation）は、コードとテストから自動的に生成・更新されるドキュメントの概念である。Cyrille Martraireが2019年の著書で体系化した。

核心的な考え方は、ドキュメントが陳腐化する問題をテスト実行と連動させることで解決する点にある。Concordionの仕様がWebサイトとして公開される例のように、テストの成功・失敗がドキュメントの信頼性を直接反映する。BDDのシナリオ、Specification by Exampleの具体例、自動テストの結果がすべて統合され、常に最新の状態を維持するドキュメント体系を形成する。

## 9. コントラクトテスト

### Pactと消費者駆動契約

コントラクトテストは、マイクロサービス間のインターフェース仕様をテストとして表現する手法である。Pactはその代表的なフレームワークであり、「消費者駆動契約（Consumer-Driven Contracts）」パターンを実装する。

仕組みは以下の通り：

1. **消費者（Consumer）**: APIの利用者がモックを使ってテストを書き、期待するリクエスト・レスポンスを定義する
2. **契約の生成**: テスト実行時にJSON形式の契約ファイルが自動生成される
3. **提供者（Provider）の検証**: 契約ファイルを使って、提供者が契約を満たすことを検証する

消費者駆動のアプローチにより、提供者は実際の利用パターンに基づいたAPIを設計できる。これはサービス間のインターフェース仕様を実行可能な形で管理する手法であり、OpenAPIなどの静的なAPI仕様とは相補的な関係にある。

## 10. ミューテーションテストと仕様の完全性

### 概念

ミューテーションテスト（Mutation Testing）は、コードに意図的に小さな変更（ミュータント）を導入し、テストスイートがその変更を検出できるかを評価する手法である。コードカバレッジが「どの行が実行されたか」のみを示すのに対し、ミューテーションテストは「テストが本当に正しい振る舞いを検証しているか」を明らかにする。

### 仕様の完全性との関係

ミューテーションテストは、仕様（テスト）の完全性を測る指標として機能する。ミュータントが「生存」した場合、それはテストスイートがその振る舞いを仕様として十分に記述していないことを意味する。主要ツールとしては、Java向けの**PIT（PITest）** と、JavaScript/TypeScript/C#向けの**Stryker Mutator** がある。

## 11. 手法の比較と関係性

| 手法 | 主な対象 | 仕様の形式 | 主な利用者 |
|------|---------|-----------|-----------|
| TDD | 単体レベル | テストコード | 開発者 |
| BDD/Gherkin | 振る舞いレベル | Given-When-Then | 開発者・ビジネス |
| ATDD | 受け入れレベル | 表形式・シナリオ | 三者協調 |
| Property-Based | 性質レベル | プロパティ宣言 | 開発者 |
| Contract Testing | サービス間 | 契約ファイル | 開発者 |
| Mutation Testing | テスト品質 | ミュータント分析 | 開発者・QA |

これらの手法は相互排他的ではなく、層をなして組み合わせることでより堅牢な仕様体系を構築できる。TDDが単体レベルの仕様を、BDD/ATDDがビジネスレベルの仕様を、コントラクトテストがサービス間の仕様を、ミューテーションテストが仕様の完全性を、それぞれ担保する。

## 12. まとめ：テストと仕様の統合

テスト駆動の仕様記述手法は、「仕様は実行可能であるべき」という根本的な洞察に基づいている。従来の仕様書が静的なドキュメントとして陳腐化していく問題に対し、テストという形で仕様を表現することで、仕様の正確性をシステムの実行によって継続的に検証できる。

この流れは、TDDの「仕様としてのテスト」から始まり、BDDの「ビジネスが読める仕様」、Specification by Exampleの「具体例による仕様」、Living Documentationの「生きた仕様書」へと発展してきた。近年では、Property-Based Testingによる宣言的な性質の記述や、コントラクトテストによるサービス間仕様の管理など、テスト駆動仕様の適用範囲は広がり続けている。
