# 記号実行（Symbolic Execution）

## 1. 概要

記号実行（Symbolic Execution）は、プログラムのどの入力が各部分を実行するかを決定するためのプログラム解析手法である。通常の実行が具体的な入力を取得するのに対し、記号実行はインタープリタが入力に対して記号的な値を仮定し、プログラム内の式や変数に対してそれらの記号に関する式を導出し、各条件分岐の可能な結果に対する制約を生成する[1][2]。

## 2. 基本原理

### 2.1 記号的値と記号実行の仕組み

記号実行の核心的なアイデアは、すべての可能な入力を表す記号変数を用いてプログラムを解析することである[2]。具体的な値の代わりに記号変数を使用することで、記号実行エンジンは複数の実行パスを体系的に探索でき、より高いコードカバレッジとより精密なバグ発見が可能になる[2]。

**実行プロセス**：
1. 入力を記号変数として扱う
2. プログラムを実行し、記号式を追跡する
3. 条件分岐ごとにパス条件を構築する
4. 制約ソルバーを用いて実行可能なパスを見つける

### 2.2 パス条件（Path Conditions）

各パスは、分岐命令での プログラム状態のコピーと、パス制約が割り当てられる[1]。例えば、if分岐の場合、パス制約は `λ * 2 == 12` となり、else分岐の場合は `λ * 2 != 12` となる[1]。

パス条件は制約ソルバーに渡され、実行可能なパスが存在する場合、特定の動作やバグをトリガーする具体的な入力を生成する[1]。

### 2.3 制約解決とSMTソルバー

動的記号実行は、SMTソルバーを用いてプログラムを通るパスを体系的に探索する自動化されたプログラム解析手法である[3]。

**動作原理**：
- 入力を記号としてモデル化する
- それらがプログラムの制御フローにどう影響するかを追跡する
- パス条件を構築する：特定のパスをたどるために必要な入力を記述する論理式
- 記号実行器は制約ソルバー（通常はZ3などのSMTソルバー）を使用して、各パス制約を満たす実際の値を見つける[3][4]

**パフォーマンスの課題**：
記号実行エンジンのパフォーマンスの主な障害は、制約解決に費やされる時間である[4]。記号実行はSMT解決に大きく依存し、実行時間の90%以上を一般的にソルバー活動に費やす[4]。

**最適化戦略**：
- 複数の制約ソルバーを並列に競争的に実行し、最高性能のソルバーの結果を使用する[4]
- 制約のキャッシングと再利用：SMTソルバークエリの結果を保存して再利用し、類似の制約の再計算を避ける[4]

## 3. 記号実行ツール

### 3.1 KLEE

KLEEは、スタンフォード大学で最初に設計され、現在は主にインペリアル・カレッジ・ロンドンのソフトウェア信頼性グループによって開発・保守されている人気の動的記号実行エンジンである[5]。KLEEは、LLVMコンパイルフレームワーク上に構築された記号実行ツールで、複雑で環境集約的なプログラムの高カバレッジのためのテストケースを自動生成する[5]。

**パス爆発問題**：
KLEEと記号実行全般の弱点はよく文書化されており、主にパス爆発と制約解決に関連している[5]。すべての実行可能なプログラムパスを記号的に実行することは、大規模なプログラムにスケールしない[5]。プログラム内の実行可能なパスの数は、プログラムサイズの増加とともに指数関数的に増加し、無限ループ反復を持つプログラムの場合には無限にさえなり得る[5]。

**パス爆発への対策**：
パス爆発問題の解決策は、一般的に以下のいずれかを使用する[5]：
- コードカバレッジを増やすためのパス発見のヒューリスティック
- 独立したパスを並列化することで実行時間を短縮
- 類似のパスをマージすることで削減

**研究開発**：
- DD-KLEE：KLEEの上に実装されたデータ駆動記号実行エンジン[6]
- APC（漸近的パス複雑性）：KLEEによるパス爆発の効果的で高速な予測器[6]
- パスマージング：事前またはランタイムでパスをマージすることもパス爆発の緩和に役立つ[6]

### 3.2 SAGE

MicrosoftのSAGEツールは、動的記号実行を使用する最も有名な商用ツールである[7]。SAGEは、Microsoftで開発されたホワイトボックスファズテスト用の記号実行ツールで、concolicまたはオフライン変種の動的記号実行に基づいており、x86命令を記号的に実行することでバイナリレベルで動作する[7]。

### 3.3 DART

DARTは、動的テスト生成を組み合わせた最初のconcolicテストツールである[8]。2005年にPatrice Godefroid、Nils Klarlund、Koushik Senによって「DART: Directed Automated Random Testing」で概念が導入され、議論された[8]。

### 3.4 EXE/KLEE

EGT（後にEXEに改名、さらに改良されてKLEEに改名）と呼ばれる類似のアイデアに基づくツールが、Cristian CadarとDawson Englerによって2005年に独立して開発され、2005年と2006年に発表された[8]。EXEは、Cプログラムの単体テストにconcolicテストを適用したツールの1つである[8]。

### 3.5 angr

angrは、Pythonのためのオープンソースのバイナリ解析プラットフォームである[9][10]。カリフォルニア大学サンタバーバラ校のコンピュータセキュリティラボ、アリゾナ州立大学のSEFCOM、彼らの関連CTFチームであるShellphish、オープンソースコミュニティによってもたらされたプラットフォーム非依存のバイナリ解析フレームワークである[9]。

**主要機能**：
- 静的および動的記号（「concolic」）解析の両方を組み合わせる[9]
- 逆アセンブル、中間表現リフティング、プログラム計装、記号実行、制御フロー解析、データ依存性解析、値集合解析（VSA）、デコンパイルなどのツールを提供[10]

**記号実行能力**：
記号実行は、プログラムの複数の実行パスを同時に探索するために使用されるプログラム解析技術である[10]。特定の入力でプログラムを実行する通常の実行とは異なり、記号実行は入力を具体的な値ではなく記号変数として扱う[10]。これにより、実行は記号式を持つ広範囲の入力を表現できる[10]。

**応用**：
- セキュリティ解析：記号実行は、標準テストで見逃される可能性のある入力検証エラーなどの脆弱性を発見できる[10]
- 自動テスト：エッジケースやまれな実行パスをカバーする包括的なテストケースの生成を支援し、ソフトウェアシステムの堅牢性とセキュリティを向上させる[10]

**ライセンス**：
angrは、寛容なBSDライセンスの下でフリーオープンソースソフトウェアとしてリリースされている[10]。

## 4. 動的記号実行（Concolic Execution）

### 4.1 定義

Concolicテスト（concreteとsymbolicのかばん語、動的記号実行としても知られる）は、具体的な実行パスに沿って記号実行を実行するハイブリッドソフトウェア検証技術である[7]。

動的記号実行（DSE）、動的テスト生成としても知られるものは、具体的な実行が記号実行を駆動する方式である[7]。記号実行は、コードカバレッジを最大化し、より正確なバグ発見を目指して、自動化された定理証明器または制約ソルバーと組み合わせて使用され、新しい具体的な入力（テストケース）を生成する[7]。

### 4.2 2つのDSEアプローチ

動的記号実行には2つの主要なスタイルがある[7]：

1. **オフラインDSE（Concolic Execution）**：
   - 具体的な実行に依存して記号実行を駆動する
   - 計装されたインタープリタ/シミュレータを使用して、具体的な値で実行しながら記号表現を構築する
   - DARTバリファイアで使用された方式

2. **オンラインDSE**：
   - 操作への入力が具体的な場合は具体的な実行を使用し、入力が記号的な場合は記号実行を使用することで、具体的な実行と記号実行を混合する

### 4.3 歴史

Concolicテストは2005年に導入され、SMTソルバーの効率と表現力の劇的な改善により重要性が高まった[8]。

**CUTEツール**：
CUTEツールは「concolic」という用語を「concrete」と「symbolic」の混成語として導入し、Cコードの単体テストでポインタや動的メモリ割り当てなどの複雑なデータ構造を扱うように方法を拡張した[8]。

## 5. パス爆発問題と対策

### 5.1 パス爆発とは

パス爆発は、条件文で実行パスが分岐するにつれて、探索すべきパスの数が設計内の分岐点の数と解析されるクロックサイクルの数に対して指数関数的に増加するという事実を指す[11][12]。探索されるパスの数は分岐因子に対して指数関数的になり得る[11]。さらに、解析されるソフトウェアがループを持つ場合、パスの数は無限になる可能性がある[11]。

記号実行のスケーラビリティは、しばしばパス爆発によって制限される。すなわち、プログラムの実行を表す記号状態の数である[2]。パス爆発の一般的な原因は記号条件を持つループであり、入れ子の条件文もパス爆発の主要な要因である[2]。

### 5.2 対策：パスマージング（State Merging）

状態マージングは、記号実行におけるパス爆発を緩和するための標準的な技術である[13]。ツールが探索する必要がある状態の数を減らす1つの方法は、異なるパスで得られた状態をマージすることである[13]。

**基本概念**：
中心的なアイデアは、同じプログラム位置にある類似のパスをマージすることである[13]。パスマージングは「状態マージング」に特化でき、同じプログラム位置にある類似の状態をマージすることで、探索すべきパスの数が指数関数的に減少する[13]。

**アプローチ**：

1. **静的状態マージング**：
   - 対象プログラムの制御フローグラフをトポロジカル順序で探索し、可能な場合は同じプログラム位置で状態をマージする[14]

2. **動的状態マージング**：
   - 2つの状態をマージするために、同じプログラム位置にある必要はない[14]
   - 異なるプログラム位置にある2つの状態が与えられた場合、一方の推移的後続が他方と高い有益な類似性を持つ場合、動的状態マージングはその状態を早送りし、他方とマージする[14]

**現代的技術**：

MultiSEは、補助変数を使用せずに記号実行中に状態を段階的にマージする技術で、各変数は値サマリと呼ばれるガード付き記号式の集合にマッピングされる[14]。値サマリは、複数のパスに沿った記号式とパス制約の共有を可能にし、したがって冗長な実行を回避する[14]。

### 5.3 その他の対策

- **ヒューリスティックなパス探索**：コードカバレッジを増やすためのパス発見戦略
- **並列化**：独立したパスを並列に実行
- **選択的記号実行**：重要な部分のみを記号的に実行
- **機械学習の活用**：実行可能でないパスの枝刈り[2]、パス探索戦略の学習

## 6. 記号実行による仕様検証

### 6.1 テスト生成

記号実行に基づくホワイトボックステストケース生成の焦点は、入力引数の内容が具体的な値ではなく記号変数であるプログラムの実行を含む[15]。ほとんどの場合、記号実行は、配列への境界外アクセス、ゼロ除算、ヌルポインタの返却、または特定のセキュリティ違反などの一般的な欠陥を探すために使用される[15]。

**実用的な応用**：
記号実行は、近年、複雑な実世界のソフトウェアで高カバレッジのテストスイートを生成するため、および深いコーナーケースバグを発見するための非常に効果的な技術として認識されている[4]。

### 6.2 検証条件生成との比較

検証条件（VC）は、有効であれば、プログラムがその指定された性質を満たすことを保証する論理式である[15]。記号実行と検証条件生成（VCG）の相互作用は、自動化されたソフトウェアおよびハードウェア検証、テスト入力生成、セキュリティ解析、分離論理における自動推論、モデル検査、制約解決パフォーマンスの最適化における基礎である[15]。

**アプローチの比較**：
自動プログラム検証器の構築には2つの支配的なアプローチがある：検証条件生成（VCG）と記号実行（SE）であり、両方の技術が強力なプログラム検証器の開発に使用されてきた[15]。結果は、SEを介した検証がVCGを介したものよりも約2倍速いことを示している[15]。

### 6.3 現代の発展

PALM は、記号実行とLLMを組み合わせたJavaプログラムのテスト生成システムで、列挙された各パスに対して、LLMを使用してパス実行テスト入力を生成する[15]。

## 7. 記号実行の限界

### 7.1 主要な課題

記号実行の主要な課題には、パス爆発、制約解決の困難さ、環境モデリングが含まれる[11]。

### 7.2 パス爆発

前述の通り、実行可能なパスの数は指数関数的に増加し、無限になる可能性がある。

### 7.3 制約解決

古典的記号実行の主な制限は、対処できないパス制約をもたらす実行可能な実行を探索できないことである[11]。健全性の喪失は、実行器によって追跡できない外部コードから、また非線形算術や超越関数などを含む複雑な制約から生じる[11]。

### 7.4 環境モデリング

控えめなアプリケーションでさえ、I/O操作、ネットワーク通信、ハードウェア周辺機器とのインターフェース、または他の外部コンポーネントとの相互作用を通じて環境と相互作用する必要がある[11]。記号実行エンジンにとっての課題は、これらの相互作用を記号的にどのように表現するかを決定することである[11]。その結果、記号実行エンジンは、不健全な仮定を回避したり、重要なパスを見逃したりしないように、ファイルシステム、プロトコル、デバイスを十分な忠実度でシミュレートする必要がある[11]。

### 7.5 メモリ集約的操作

記号実行でメモリ集約的操作を考慮する際には、2つの主要な課題がある[11]：
- (a) これらの操作に関与するメモリアドレスが記号的である可能性がある
- (b) これらの操作が操作する必要があるバイト数、すなわちサイズが記号的である可能性がある

### 7.6 スケーラビリティの制限

網羅的な記号実行は、小さなアプリケーションを超えてスケールする可能性は低い[11]。したがって、実際には、パフォーマンスのために健全性を犠牲にするなど、より控えめな目標に落ち着くことが多い[11]。

### 7.7 2025年の展望

最近の研究では、形式言語への翻訳なしに、大規模言語モデルが直接推論できる汎用コードベースの表現を使用してパス制約を一般化している[2]。AutoBugは、軽量で言語非依存のLLMベースの記号実行エンジンである[2]。

## 8. 記号実行とテスト生成

### 8.1 自動テスト生成

記号実行は、自動テスト生成の強力な手段を提供する[15]。記号実行を使用することで、以下が可能になる：

- 高カバレッジのテストケースの自動生成
- エッジケースやコーナーケースの発見
- バグを引き起こす具体的な入力の特定

### 8.2 ホワイトボックステスト

Concolicテストは、もともと、確立されたランダムテスト方法論に対するホワイトボックスの改善として考えられた[8]。

### 8.3 産業界での応用

記号実行は、セキュリティテスト、ソフトウェア検証、脆弱性発見など、さまざまな実用的なアプリケーションで使用されている[16]。

## 9. まとめ

記号実行は、プログラム解析とテスト生成のための強力な技術である。その主要な特徴と課題は以下の通り：

### 9.1 強み

1. **体系的なパス探索**：すべての実行パスを網羅的に探索できる可能性
2. **高いコードカバレッジ**：通常のテストでは到達しにくいパスを発見
3. **バグの発見**：深いコーナーケースバグを自動的に発見
4. **テストケース生成**：特定のパスを実行する具体的な入力を自動生成

### 9.2 課題

1. **パス爆発**：実行可能なパスの数が指数関数的に増加
2. **制約解決の複雑さ**：SMTソルバーが実行時間の大部分を占める
3. **環境モデリング**：外部環境の記号的な表現が困難
4. **スケーラビリティ**：大規模プログラムへの適用が困難

### 9.3 対策と将来の方向性

- パスマージング（状態マージング）による効率化
- 機械学習を用いたパス探索戦略の最適化
- 大規模言語モデル（LLM）との統合
- 並列化と分散実行
- 選択的記号実行

記号実行は、形式手法とソフトウェアテストの交差点に位置し、仕様検証とバグ発見の両方に貢献する重要な技術である。完全な網羅性とスケーラビリティのトレードオフを理解しながら、適切に適用することで、ソフトウェアの品質とセキュリティを大幅に向上させることができる。

## 参考文献

1. [Symbolic execution - Wikipedia](https://en.wikipedia.org/wiki/Symbolic_execution)
2. [Large Language Model Powered Symbolic Execution](https://www.arxiv.org/pdf/2505.13452)
3. [Constraint Solving in Symbolic Execution - Cristian Cadar](http://srg.doc.ic.ac.uk/files/slides/symex-smt-15.pdf)
4. [Parallel SMT Solving and Concurrent Symbolic Execution](https://ieeexplore.ieee.org/document/7345624)
5. [KLEE symbolic execution engine in 2019](https://link.springer.com/article/10.1007/s10009-020-00570-3)
6. [Metrinome: Path Complexity Predicts Symbolic Execution Path Explosion](https://www.cs.hmc.edu/~bang/research/metrinome.pdf)
7. [Concolic testing - Wikipedia](https://en.wikipedia.org/wiki/Concolic_testing)
8. [GitHub - awesome-symbolic-execution](https://github.com/ksluckow/awesome-symbolic-execution)
9. [angr](https://angr.io/)
10. [Symbolic Execution - angr documentation](https://docs.angr.io/en/latest/core-concepts/symbolic.html)
11. [Symbolic Execution in Practice: A Survey](https://arxiv.org/pdf/2508.06643)
12. [A Survey of Symbolic Execution Techniques](https://arxiv.org/pdf/1610.00502)
13. [Efficient state merging in symbolic execution](https://dl.acm.org/doi/10.1145/2345156.2254088)
14. [MultiSE: Multi-Path Symbolic Execution using Value Summaries](https://people.eecs.berkeley.edu/~ksen/papers/multise.pdf)
15. [Test Generation Using Symbolic Execution - Patrice Godefroid](https://patricegodefroid.github.io/public_psfiles/fsttcs2012.pdf)
16. [Symbolic Execution for Software Testing: Three Decades Later](https://people.eecs.berkeley.edu/~ksen/papers/cacm13.pdf)
