# RFC・実世界標準仕様のケーススタディ

## 概要

実世界の標準規格（RFC、IEEE、ISO等）における仕様の隙間、曖昧性、実装間差異の具体的事例を調査する。RFCなどの標準化文書でも仕様に隙間があり、実装系によって動作が異なる現象が広く存在する。本調査では、HTTP/1.1、TLS、TCP/IP、HTML/CSS、Unicode、IEEE 754等の主要プロトコル・規格を対象に、仕様の隙間が引き起こした実際の問題事例を分析する。

## RFC 2119: 要求レベルの階層化

### 仕様記述のための標準キーワード

[RFC 2119](https://datatracker.ietf.org/doc/html/rfc2119)は、RFC文書内で要求の強度を示すための標準化されたキーワードを定義している。これ自体が、仕様の曖昧性を減らすためのメタ仕様として機能する：

- **MUST / REQUIRED / SHALL**: 絶対的な要求事項。仕様の必須要件を示す
- **SHOULD / RECOMMENDED**: 特定の状況下では無視する正当な理由があり得るが、その影響を十分に理解し慎重に検討する必要がある推奨事項
- **MAY / OPTIONAL**: 完全に任意の項目。実装者が選択できる

### RFC 2119の限界と拡張

RFC 2119キーワードは、相互運用性のために実際に必要な場合、または害を及ぼす可能性のある動作（例：再送信の制限）を制限する場合にのみ使用すべきとされている。しかし、脅威モデルが曖昧で緩和策が不明確または不便な場合、RFC 2119のキーワードでは十分に細かい要求を表現できない。このため、[RFC 6919](https://www.rfc-editor.org/rfc/rfc6919)がより微妙な要求表現のための追加キーワードを提供している。

この階層化された要求レベル自体が、実装の多様性を許容する仕組みとなっており、「仕様の隙間」を意図的に作り出している側面がある。

## HTTP/1.1: パイプライニングの失敗

### 仕様と実装の乖離

[HTTP/1.1仕様](https://datatracker.ietf.org/doc/html/rfc2616/)は、パイプライニング（複数のリクエストを待機せずに連続送信する技術）を正しく処理することをサーバーに要求していた。しかし、実装の現実は大きく異なった。

### 実装上の問題点

**ブラウザサポートの状況**:
- Opera: 唯一、デフォルトで有効な完全実装を持つ
- Internet Explorer 8: バグのあるプロキシやヘッドオブラインブロッキングへの懸念から未サポート
- Mozilla Firefox: 当初サポートしていたがFirefox 54で削除
- Google Chrome: 以前はサポートしていたが、問題のあるサーバーとのバグにより無効化
- 現代のブラウザ（Chrome、Safari、新しいFirefox）: HTTPパイプライニングを完全に放棄

**技術的課題**:

1. **ヘッドオブラインブロッキング**: レスポンスは要求の順序で返される必要があるため、1つの要求が遅延すると後続のすべてのレスポンスが待機状態になり、パイプライニングの性能上の利点が無効化される

2. **プロキシとサーバーの互換性**: 多くのレガシーHTTP/1.1サーバーはパイプライニングを正しくサポートしていない。パイプライン化されたリクエストのうち最初のものだけを処理して他を破棄したり、最初のリクエスト後にデータがあるために接続を閉じたり、レスポンスを順不同で返したりする

3. **仕様のガイダンス不足**: [RFC 2616](https://datatracker.ietf.org/doc/html/rfc2616/)は、中間プロキシが存在する場合のパイプライニング互換性を確実に検出する方法についてのガイダンスを提供していなかった。仕様は沈黙しており、この曖昧性がHTTPパイプライニングの採用を非常に限定的なものにした

### 解決策

HTTP/2とSPDYの非同期操作が解決策となり、2017年までにほとんどのブラウザがデフォルトでマルチプレクシングを使用するHTTP/2をサポートするようになった。

## TLS: プロトコルと実装の脆弱性

### プロトコル仕様の脆弱性 vs 実装の脆弱性

TLSセキュリティの問題は、仕様レベルの設計上の欠陥と実装レベルのバグの両方に起因する。

**実装特有の脆弱性の例**:
- **Heartbleed**: OpenSSLソフトウェアのバッファオーバーリードバグであり、SSL/TLSプロトコル仕様の欠陥ではない。この脆弱性により、SSL/TLS暗号化で保護された情報を盗むことが可能だった。サーバーの秘密暗号化鍵を取得できる可能性があり、クライアントとサーバー間のトラフィックを復号化できる危険性があった

**プロトコル設計の脆弱性の例**:
- **POODLE** (Padding Oracle On Downgraded Legacy Encryption): SSL 3.0へのフォールバックを利用するセキュリティ脆弱性。プロトコル設計のバグであり、実装に依存しない。攻撃者は平均256回のSSL 3.0リクエストで暗号化メッセージの1バイトを明らかにできる

- **Logjam**: TLSプロトコル自体の基本設計のバグによるもので、TLSを使用してエンドユーザーとの安全な接続を確立するすべてのWebブラウザと一部のメールサーバーが攻撃に対して脆弱だった

### TLS 1.2から1.3への進化

**TLS 1.2の脆弱性**:
- パディングオラクル攻撃により平文が漏洩する可能性
- 多くの脆弱性は、弱い設定やレガシー暗号のサポートに起因（プロトコル自体の欠陥ではない）

**TLS 1.3の改善**:
- CBCの使用を禁止し、AEAD暗号スイートの必須化によりパディングオラクル攻撃を排除
- しかし、TLSライブラリはTLS 1.3の新しいステートマシン実装を導入し、しばしば新たな脆弱性を含む
- クライアント側ライブラリでは、Webサーバーと比較してTLS 1.3の重要なセキュリティ機能が完全に実装されていないことが多く、様々なセキュリティ上の懸念につながっている

### OpenSSL、LibreSSL、BoringSSLの実装差異

**起源と目的**:
- **LibreSSL**: 2014年4月にHeartbleed脆弱性への対応としてOpenSSL 1.0.1gからフォーク。コードベースの近代化、セキュリティ向上、開発ベストプラクティスの適用を目標とする
- **BoringSSL**: 2014年にGoogleが公開したOpenSSLのフォーク。Chrome、Android、サーバーインフラなど様々なGoogle製品での使用のためにGoogleが独自に保守していたパッチをまとめたもの

**API互換性のアプローチ**:
- **LibreSSL**: OpenSSLとのAPIおよびABI互換性を維持することを目標とし、ドロップイン置換として扱える
- **BoringSSL**: OpenSSLとのAPI互換性を目指さず、以前のBoringSSLのバージョンとも互換性を保証しない。GoogleはライブラリAPIを自由に変更したいため

**機能と軽量性**:
- **BoringSSL**: Googleが必要とするレガシーアプリケーションサポートがはるかに少ないため、API/ABIの安定性を保証しないはるかに軽量なOpenSSLバージョン
- 両ライブラリとも、古く不人気なアルゴリズムと機能をサポートする元のOpenSSLコードの多くを削除

**TLS機能サポート**:
- 一般的に、ほとんどの新しいTLS機能は他のフォークよりも先にBoringSSLで実装・サポートされている
- 2022年末以降、LibreSSL 3.7.0とBoringSSLの両方は、TLS-SRPを除いてOpenSSL（正確にはquictlsフォーク）と完全に同等

これらの実装差異は、同じTLS仕様であっても、実装の目的や設計思想によって全く異なる振る舞いを示す可能性があることを示している。

## IEEE 754: 浮動小数点演算の実装差異

### 標準化の成果と残された問題

[IEEE 754標準](https://en.wikipedia.org/wiki/IEEE_754)は1985年に確立され、移植性と信頼性の高い使用を困難にしていた多様な浮動小数点実装の多くの問題に対処した。しかし、標準化後も実装間で重要な差異が存在する。

### 拡張精度フォーマットの実装差異

最も重要な実装差異の1つは、拡張精度フォーマットに関連している：

- **Intel x86ファミリー**: 拡張倍精度フォーマットの完全サポートを提供するが、単精度と倍精度は部分的サポートのみ。x86プロセッサは結果を単精度または倍精度フォーマットの精度に丸めるが、拡張倍精度フォーマットと同じ範囲を保持する

### プラットフォーム間の主な違い

- 同じ入力が与えられた場合、CPUとGPU上で個々のIEEE 754演算は同じ結果を与えるが、CPUとGPUで同じ演算シーケンスが実行されるとは限らない。なぜなら、GPUは融合積和演算を持つがCPUは持たないため、また並列化アルゴリズムが演算を並べ替える可能性があるため

- CPUは予想よりも高い精度で結果を計算する可能性がある

- 多くの一般的な数学関数は、IEEE 754標準では正しく丸められることを要求されていない

### 丸め誤差と丸めモード

IEEE 754標準は4つの丸めモードを定義している：最近接への丸め、正方向への丸め、負方向への丸め、ゼロ方向への丸め。最も頻繁に使用されるのは最近接偶数への丸めモード。

**二重丸めの問題**:
各演算がまず拡張倍精度に丸められ、次に倍精度に丸められる場合、各演算が正しく倍精度に丸められる場合とは異なる結果を生じる可能性がある。この二重丸め現象により、通常は正しく機能するアルゴリズムが予期せず失敗する可能性がある。

**表現誤差**:
ほとんどの10進数の分数は2進数（基数2）の分数として正確に表現できない。浮動小数点演算の誤差は浮動小数点ハードウェアから継承され、1演算あたり最大で2^53分の1のオーダーだが、すべての浮動小数点演算は新しい丸め誤差を被る可能性がある。

## HTML/CSS: ブラウザ実装の多様性

### 実装差異が存在する理由

各ブラウザはCSS仕様の独自実装を持ち、ブラウザがCSSコードを解釈してWebページをレンダリングする方法に違いが生じる。異なるブラウザは異なる時期にサポートを実装し、仕様の一部を他の部分より先にサポートする可能性があり、ブラウザ開発者は仕様の解釈が異なる可能性がある。

### 主要な互換性問題

**デフォルトスタイリングの違い**:
すべてのブラウザは、HTMLに適用するデフォルトのCSSルールセットを持っている。これらのデフォルトCSSルールは、ユーザーエージェントスタイルシートと呼ばれるブラウザ固有のスタイルシートに存在する。

**機能サポートの不整合**:
異なるブラウザは異なる時期に新機能を追加する。ブラウザはこれらの機能のサポートが異なるのは、異なるブラウザが異なる機能の実装を優先する傾向があるため。

**ベンダープレフィックス**:
すべてのブラウザは多くの新しいCSSルールの独自実装を持っており、自身の実装を区別するために、ブラウザはベンダープレフィックスと呼ばれるプレフィックスをCSSプロパティに追加する。

### 仕様開発プロセス

CSSの新機能はCSS Working Groupによって設計されてブラウザベンダーに完成した形で渡されるわけではない。実験的実装が行われて初めて、仕様のより細かい詳細をすべて解決できることが多く、機能開発は反復的プロセスである。

### WHATWG HTML Living StandardとW3C HTML仕様の分裂

**歴史的経緯**:
2006年、W3CはHTML5開発への参加に関心を示し、2007年にWHATWGとHTML5仕様に取り組むワーキンググループを形成した。Apple、Mozilla、OperaはW3C著作権の下でW3Cが仕様を公開することを許可し、同時にWHATWGサイトでより制限の少ないライセンス版を維持した。数年間、両グループは協力して作業した。

**分裂**:
2011年、両グループは異なる目標を持つと結論付けた。W3Cは「HTML5」の「完成した」バージョンを公開したいのに対し、WHATWGはHTMLのLiving Standardに継続的に取り組み、仕様を継続的に維持したいと考えた。

**競合する標準**:
W3CとWHATWGは2012年以降、競合する標準を公開していた。W3C標準は2007年にWHATWGと同一だったが、異なる設計決定により標準は徐々に分岐した。WHATWG「Living Standard」はしばらくの間、事実上のWeb標準だった。

**最近の解決**:
2019年5月28日、W3CはWHATWGがHTMLおよびDOM標準の唯一の公開者になると発表した。

## Unicode: 正規化の実装差異

### 仕様の不整合

サンプルコードが正しい解決策を実装していたが、形式的定義に従った既存の実装は、コードに従った実装と異なり、問題のあるシーケンスを含むテキストを正規化する際に異なる結果をもたらした。これは、形式仕様とその参照実装の間の重要なギャップを示している。

### バージョン互換性問題

一部の実装は仕様の意図に従ったが、他の実装は訂正がすでに適用されたかのように動作した。以前のバージョンに対してプロセスの安定性を保証する実装を開発する際、どのタイプの以前のUnicode実装をターゲットにしているかを知ることが重要である。これは異なる実装世代間での相互運用性の課題を生み出す。

### 実世界の実装乖離

2つのアプリケーションがUnicodeデータを共有するが、異なる正規化を行う場合、エラーとデータ損失が生じる可能性がある。OS Xがファイル共有ソフトウェアからUnicodeファイル名を正規化したが、ソフトウェアは変更されたファイル名を同等として認識しなかった例がある。

### コミュニケーションのギャップ

正規単一文字がUnicodeに追加されてから15年以上経つが、著者やオーサリングツールの実装者に、正規単一文字をその優先分解文字と同一に扱う必要性を伝える努力が不十分だった。

### パフォーマンス vs 仕様準拠

Unicode標準とその付属文書に記述されているアルゴリズムに従うと、当初、同等の実装と比較して約50倍遅い実装になった。パフォーマンスの差を約10倍に減らすには、大幅な最適化が必要だった。

## TCP/IP: 輻輳制御の仕様曖昧性

### 仕様の曖昧性と実装差異

独立したチームによる複数の実装は、仕様が前提や曖昧性を回避したことを保証するのに役立つ。これは根本的な課題を浮き彫りにする：TCP/IP仕様には異なる実装アプローチにつながる曖昧性が含まれる可能性がある。

### 実装が仕様となる問題

輻輳制御メカニズムの仕様は、通常Cで実装されたカーネルレベルのコードで表現される。実装が事実上仕様である場合、どの実装が権威的かという問題が生じる。答えは、その時代の支配的なオープンソース実装だった。これは重要な現実を明らかにする：複数の実装が存在する場合、単一の参照標準はしばしば存在せず、支配的な実装が事実上の仕様となる。

### 歴史的事例: セグメントサイズの曖昧性

仕様の曖昧性の1つの文書化された事例は、セグメントの送信に関するものである：

- 元の仕様はこの点について沈黙していた
- TCPの初期実装は、半分満たされたセグメントを送信することを決定した
- 利用可能なウィンドウを積極的に利用する戦略は、現在「silly window syndrome」として知られる状況につながった
- これにより、Nagleのアルゴリズムとして知られるより洗練された決定プロセスの導入が必要になった

### 輻輳制御アルゴリズムのバリエーション

インターネットに接続するコンピュータのオペレーティングシステムのプロトコルスタックには、アルゴリズムのいくつかのバリエーションとバージョンが実装されている。異なるTCP実装は異なる輻輳制御アルゴリズム（Tahoe、Reno、CUBIC、BBR等）を使用しており、より広いTCP/IPフレームワーク内で可能な柔軟性と変動を反映している。

## DNS: リゾルバ実装の違いとキャッシュポイズニング

### DNSリゾルバの実装差異

**BINDとUnboundの違い**:
追加セクションのRRsetに対するデフォルトのキャッシングポリシーには重要な違いがある：
- **BIND**: 追加セクションからのドメインラベルとIPアドレスを含むすべてのマッピングをキャッシュする
- **Unbound**: 追加セクションをキャッシュするが、これらのマッピングをクエリの答えとしてクライアントに送信しない

キャッシュポイズニングの検出は、キャッシングの正規の動作を厳密に定義する厳格なDNS RFCの欠如により特に困難である。リゾルバ実装間の不整合の比率が高いことは、実装間に大きな多様性があることを示しており、不整合は通常、脆弱性を意味するわけではない。

### キャッシュポイズニング脆弱性

3つの実装（BIND、Unbound、MaraDNS）すべてが、DNSキャッシュを更新するために使用するプロトコルが本質的に弱いため、異なるタイプのキャッシュポイズニング攻撃によって侵害される可能性がある。

**RFCポリシーの問題**:
RFC 2181は、「権威内」（この名前の権威であるべきサーバーからの）であれば、補助データをその後のクエリ処理のためにグローバルスコープ（キャッシュ）に受け入れることを許可している。この補助データのキャッシングが、「勝つまで競争」のKaminskyブラインドキャッシュ攻撃を可能にする。

### 現代の防御メカニズム

リゾルバ実装は現在、ランダム化されたエフェメラルポート番号とDNSトランザクションIDを使用する必要があり、リゾルバは0x20エンコーディングを採用して質問セクションの名前の大文字と小文字を混在させている。

最近の研究により、EDNS Client Subnet（ECS）オプションの欠陥のある実装が、DNSクエリ集約防御をバイパスするために悪用される可能性があることが明らかになった。攻撃者は、異なるECSオプションを持つクエリを作成することで、リゾルバに同じドメイン名に対する複数の同時クエリを発行させることができる。

## JSON: 実装の自由度と不一致

### 重複オブジェクトキー

オブジェクト内の名前が一意でない場合、そのようなオブジェクトを受信するソフトウェアの動作は予測不可能である：
- 多くの実装は最後の名前/値ペアのみを報告する
- 他の実装はエラーを報告するか、オブジェクトの解析に失敗する
- 一部の実装は、重複を含むすべての名前/値ペアを報告する

### オブジェクトメンバーの順序付け

JSONパースライブラリは、オブジェクトメンバーの順序付けを呼び出しソフトウェアに見えるようにするかどうかが異なる。メンバーの順序付けに依存しない動作を持つ実装は、これらの違いの影響を受けないという意味で相互運用可能である。

### JavaScript固有の解析の癖

JSONはJavaScriptのサブセットだが、代入と呼び出しを除外している。JSONの構文はJavaScriptから借用されているため、そのJavaScriptの"eval()"関数を使用してほとんどのJSONテキストを解析することが可能（ただしすべてではない。U+2028 LINE SEPARATORやU+2029 PARAGRAPH SEPARATORなどの特定の文字は、JSONでは合法だがJavaScriptでは合法でない）。

### 文字列比較の問題

エスケープされた文字を変換せずに文字列を比較する実装は、"a\\b"と"a\u005Cb"が等しくないと誤って判断する可能性がある。

### 設定可能な実装制限

実装は、受け入れるテキストのサイズに制限を設定する可能性がある。実装は、ネストの最大深度に制限を設定する可能性がある。実装は、数値の範囲と精度に制限を設定する可能性がある。

## WebSocket: ハンドシェイクの柔軟性と問題

### ハンドシェイクの概要

プロトコルは、TCP上に層化されたオープニングハンドシェイクとその後の基本的なメッセージフレーミングで構成される。クライアントはHTTPリクエスト（メソッドGET、バージョン≥1.1）を送信し、サーバーは成功時にステータスコード101（Switching Protocols）のHTTPレスポンスを返す。

### ハンドシェイクの柔軟性と互換性

RFC 2616に準拠して、ハンドシェイクのヘッダーフィールドはクライアントによって任意の順序で送信される可能性があるため、異なるヘッダーフィールドを受信する順序は重要ではない。さらに、追加のHTTPヘッダー（以下の表にないもの）の送信は許可されており、HTTPヘッダーは任意の順序で送信される可能性がある。

### RFC 6455の既知のエラータ問題

RFC仕様自体に文書化された問題がある：

1. **Sec-WebSocket-Keyエンコーディングのテストベクター**: RFC 6455セクション4.1で提供されたテストベクターが間違っている。RFC 4648セクション3.5で言及されている「不適切に実装された」base 64エンコーダーによって処理された。パディングビットがゼロに設定されていなかった

2. **大文字小文字の問題**: HTTPアップグレードトークンは大文字小文字を区別し、RFC 6455によって登録されたトークンは"WebSocket"だが、実装は"websocket"を使用しているようである

### ハンドシェイクネゴシエーションの非対称性

オープニングハンドシェイクの両側間の最も重要な非対称性は、拡張機能、およびある程度はサブプロトコルのネゴシエーションにある。サーバーは両側についてすべてを知っており、接続のパラメータを決定する。

## メール: RFC違反アドレスの問題

### RFC違反アドレスとは

RFC違反アドレスとは、2連続のドット「..」が使用されていたり、@マークの直前でドット「.」を設定しているアドレスを指す。

**具体的なRFC違反パターン**:
- アットマーク（@）の直前やメールアドレスの先頭にピリオド (.) がある
- アットマーク（@）より前でピリオド (.) が連続している
- 半角英数字と一部の記号（.! # $ % & ' * + – / = ? ^ _ ` { | } ~）以外の文字列を含んでいる

### 発生背景と現在の状況

日本のキャリアメール（au、docomo）では2009年4月までRFC違反のアドレスも登録が可能だったが、2009年4月以降は登録ができなくなっている。

### 実際の問題事例

1. **iOSアップデート後の問題**: iPhone端末のOSをiOS 14にアップデート後、RFC違反アドレスを設定しているとメールの送信ができない事象が発生

2. **キャリア間の相互運用性**: RFC違反のメールアドレスは、携帯電話同士（キャリアメール間）では送受信できても、プロバイダやレンタルサーバからは送信できない場合がある

3. **Gmailでの取り扱い**: 現在Gmailでは、RFC違反のメールアドレスは取り扱うことができない

4. **Googleの対応変更**: 2008年にはGoogleが日本のビジネスに合わせてezwebとdocomo宛のみRFC違反のメールアドレスにも送信が可能とする措置をとっていたが、2015年11月よりこの措置が撤廃された

このケースは、地域的な慣習と国際標準の間の衝突、および長期にわたる互換性維持の困難さを示している。

## 相互運用性テストと適合性検証

### W3Cテストスイート

**テストスイートの種類**:
- **VC JOSE COSEテストスイート**: JOSE and COSEを使用したW3C検証可能クレデンシャルの保護仕様の相互運用性へのパスを示す
- **DIDテストスイート**: W3C分散識別子仕様の相互運用性テストを実行し、W3C DID Working Groupによって保守される

**テストスイートライセンス**:
W3Cは、グループコンセンサスプロセスを反映し、相互運用性とパフォーマンス主張の安定性を促進するために、ブランド化された「権威あるW3Cテストスイート」を作成する。W3Cは2つの異なるライセンスの下でテストスイートを利用可能にする：
- ソフトウェア開発とバグ追跡のための3条項BSDライセンス
- 権威あるW3Cテストスイート用、または仕様に関するパフォーマンス主張が必要な場合のW3Cテストスイートライセンス

### テストのカテゴリ

**適合性テスト**:
実装が仕様に適合しているかどうかを検証するために、仕様で正式に要求されているもののみをテストすることに焦点を当てる。パフォーマンス、ユーザビリティ、ストレス能力、相互運用性には焦点を当てない。

**相互運用性テスト**:
特定の仕様の異なる実装間の相互運用性の問題を見つけることに焦点を当てる。

### 適合性要件

適合性テストスイートは、仕様に準拠すると主張するソフトウェア製品が正しく実装されている確率を高める。標準の正しい実装は、移植性と相互運用性につながる。

### ISO/IEC標準の適合性テスト

**適合性評価の概要**:
適合性評価は、製品、サービス、プロセス、主張、システム、または人が関連する要件を満たしているかどうかを実証する。基本的な要件は、適合性の要件または基準が標準または仕様で指定されている必要があるということ。

**実装の柔軟性**:
一部の組織は、ISO/IEC標準で定義されたすべてのテスト文書を必要としない可能性があるため、実装には通常、組織に適したドキュメントを選択することが含まれ、組織は完全な適合性または調整された適合性のいずれかを主張できる。

## 仕様の隙間がもたらす影響

### セキュリティへの影響

- **Heartbleed、POODLE、Logjam**: 実装バグと仕様設計の欠陥の両方が、数百万のシステムに影響を与える重大なセキュリティ脆弱性につながる可能性がある
- **DNSキャッシュポイズニング**: 仕様の曖昧性が攻撃ベクトルを生み出す

### 相互運用性の問題

- **HTTPパイプライニング**: 仕様が「SHOULD」や「MUST」を定義していても、実世界のプロキシやサーバーの不適切な実装により、機能全体が使用不可能になる
- **メールアドレス**: 地域的慣習と国際標準の衝突が、長期にわたる互換性の問題を引き起こす

### パフォーマンスの影響

- **IEEE 754の二重丸め**: 実装の選択がアルゴリズムの正確性に予期せぬ影響を与える
- **Unicode正規化**: 仕様準拠の実装が50倍遅くなる可能性があり、最適化と正確性のトレードオフが必要

### 標準化プロセスへの影響

- **WHATWG vs W3C**: 異なる組織が異なる哲学（「Living Standard」vs「完成したバージョン」）を持つ場合、標準が分裂し、最終的に市場が勝者を決定する
- **OpenSSL vs LibreSSL vs BoringSSL**: 単一の仕様から複数の互換性のない実装が派生し、それぞれ異なる設計目標を持つ

## 考察

### 「仕様の隙間」の必然性

完璧な仕様を書くことは不可能である。本調査で分析したケーススタディは、実世界の標準仕様における「仕様の隙間」が以下の理由で必然的に生じることを示している：

1. **記述の限界**: 自然言語（英語など）での仕様記述は本質的に曖昧性を含む。RFC 2119のMUST/SHOULD/MAYの階層化自体が、この曖昧性を管理する試みである

2. **進化する要求**: HTTPパイプライニングやHTML Living Standardの例が示すように、技術は使用されながら進化する。「完成した仕様」という概念自体が現実と合わない場合がある

3. **実装の多様性**: IEEE 754やUnicode正規化の例が示すように、異なるプラットフォーム、異なるパフォーマンス要求、異なる設計哲学が、必然的に実装の多様性を生む

4. **セキュリティとの緊張関係**: TLSの進化が示すように、セキュリティ要求は継続的に変化し、レガシー互換性との間に緊張を生む

### 相互運用性テストの重要性

仕様の隙間を埋めるための主要な手段は、包括的な相互運用性テストである。しかし、テスト自体にも限界がある：

- **テスト可能性**: すべての仕様要件がテスト可能なわけではない
- **テストカバレッジ**: HTTPパイプライニングの例が示すように、すべての実世界の環境（特に透過プロキシなど）を事前にテストすることは不可能
- **適合性 vs 相互運用性**: 適合性テストに合格することと、実際に他の実装と相互運用できることは別の問題

### 実装が仕様になる現象

TCP/IPの輻輳制御、OpenSSL/LibreSSL/BoringSSLの分岐が示すように、「支配的な実装が事実上の仕様になる」現象は避けられない：

- 仕様が曖昧な場合、最も広く使用される実装の動作が参照となる
- これは「仕様の隙間」を埋める実用的メカニズムだが、標準化プロセスの理想とは矛盾する
- 複数の実装が並存する場合、「どれが正しいか」ではなく「どれが支配的か」が重要になる

### 許容集合としての仕様の視点

本調査のケーススタディは、仕様を「許容される実装の集合」として捉える視点を支持する：

- RFC 2119のSHOULDは、複数の「許容される」実装を明示的に認める
- JSONの重複キー処理、Unicode正規化のバージョン間差異などは、仕様が複数の動作を許容していることを示す
- このような「仕様の隙間」は欠陥ではなく、実装の多様性を許容する設計の特徴とも解釈できる

しかし、この視点には限界もある：

- セキュリティ脆弱性（Heartbleed、POODLE）は「許容される」実装ではない
- HTTPパイプライニングの失敗は、「許容される」はずの実装が実際には機能しなかった例
- 相互運用性の失敗は、「許容集合」の境界が不明確であることを示す

## 参考文献

### RFC文書
- [RFC 2119 - Key words for use in RFCs to Indicate Requirement Levels](https://datatracker.ietf.org/doc/html/rfc2119)
- [RFC 6919 - Further Key Words for Use in RFCs to Indicate Requirement Levels](https://www.rfc-editor.org/rfc/rfc6919)
- [RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1](https://datatracker.ietf.org/doc/html/rfc2616/)
- [RFC 8259 - The JavaScript Object Notation (JSON) Data Interchange Format](https://www.rfc-editor.org/rfc/rfc8259)
- [RFC 6455 - The WebSocket Protocol](https://datatracker.ietf.org/doc/html/rfc6455)

### TLS/SSL関連
- [Why use TLS 1.3? | SSL and TLS vulnerabilities | Cloudflare](https://www.cloudflare.com/learning/ssl/why-use-tls-1.3/)
- [TLS vulnerabilities, attack vectors and effective mitigation techniques](https://www.cloudinsidr.com/content/known-attack-vectors-against-tls-implementation-vulnerabilities/)
- [Heartbleed Bug](https://www.heartbleed.com/)
- [POODLE - Wikipedia](https://en.wikipedia.org/wiki/POODLE)
- [The State of SSL Stacks](https://www.haproxy.com/blog/state-of-ssl-stacks)
- [LibreSSL - Wikipedia](https://en.wikipedia.org/wiki/LibreSSL)

### HTTP関連
- [HTTP pipelining - Wikipedia](https://en.wikipedia.org/wiki/HTTP_pipelining)
- [HTTP Pipelining - Chromium](https://www.chromium.org/developers/design-documents/network-stack/http-pipelining/)
- [Evolution of HTTP - HTTP | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)

### HTML/CSS関連
- [WHATWG - Wikipedia](https://en.wikipedia.org/wiki/WHATWG)
- [HTML Standard](https://html.spec.whatwg.org/)
- [A Guide To CSS Support In Browsers — Smashing Magazine](https://www.smashingmagazine.com/2019/02/css-browser-support/)
- [12 Common CSS Browser Compatibility Issues To Avoid In 2025 | LambdaTest](https://www.lambdatest.com/blog/css-browser-compatibility-issues/)

### Unicode関連
- [UAX #15: Unicode Normalization Forms](https://unicode.org/reports/tr15/)
- [Normalization | ICU Documentation](https://unicode-org.github.io/icu/userguide/transforms/normalization/)
- [Unicode equivalence - Wikipedia](https://en.wikipedia.org/wiki/Unicode_equivalence)

### IEEE 754関連
- [IEEE 754 - Wikipedia](https://en.wikipedia.org/wiki/IEEE_754)
- [Differences Among IEEE 754 Implementations](https://grouper.ieee.org/groups/msc/ANSI_IEEE-Std-754-2019/background/addendum.html)
- [15. Floating-Point Arithmetic: Issues and Limitations — Python 3.14.3 documentation](https://docs.python.org/3/tutorial/floatingpoint.html)

### TCP/IP関連
- [TCP congestion control - Wikipedia](https://en.wikipedia.org/wiki/TCP_congestion_control)
- [RFC 2581: TCP Congestion Control](https://www.rfc-editor.org/rfc/rfc2581)
- [Specifying New Congestion Control Algorithms](https://www.rfc-editor.org/rfc/rfc9743.xml)

### DNS関連
- [RFC 9520 - Negative Caching of DNS Resolution Failures](https://datatracker.ietf.org/doc/rfc9520/)
- [The Hitchhiker's Guide to DNS Cache Poisoning](https://www.cs.cornell.edu/~shmat/shmat_securecomm10.pdf)

### テストと相互運用性
- [W3C VC JOSE COSE Test Suite](https://w3c.github.io/vc-jose-cose-test-suite/)
- [GitHub - w3c/did-test-suite](https://github.com/w3c/did-test-suite)
- [Conformance testing - Wikipedia](https://en.wikipedia.org/wiki/Conformance_testing)
- [ISO - Conformity assessment](https://www.iso.org/conformity-assessment.html)

### 日本語資料
- [RFCの読み方 - インフラエンジニアway](https://heartbeats.jp/hbblog/2023/04/rfc.html)
- [特殊な形式のアドレス（RFC違反アドレス）のご利用について | ドコモメール](https://www.docomo.ne.jp/service/docomo_mail/rfc_add/)
- [メールの送受信ができない!? RFC違反メールアドレスを知っていますか？](https://www.asobou.co.jp/blog/web/mail-rfc)
- [相互運用性 - Wikipedia](https://ja.wikipedia.org/wiki/%E7%9B%B8%E4%BA%92%E9%81%8B%E7%94%A8%E6%80%A7)
