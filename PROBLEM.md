# PROBLEM.md

## 目的

このファイルは、spec-oracleツールを使用する中で発見された問題を記録します。
問題は、実装上のバグ、使いにくさ、設計上の問題、仕様の不備などを含みます。

## 運用方法

- ユーザーまたは開発者が問題に気づいたら、このファイルに追記する
- 問題は優先度順に並べる（Critical > High > Medium > Low）
- 問題が解決されたら、チェックボックスにチェックを入れる
- 解決策や関連する変更へのリンクを記載する
- 定期的にチェック済みの古い問題を削除またはアーカイブする

## フォーマット

```markdown
- [ ] **問題の概要**
  - **発見日**: YYYY-MM-DD
  - **詳細**: 問題の詳しい説明
  - **再現手順**: （該当する場合）
  - **影響範囲**: どの機能/ユーザーに影響するか
  - **どうあって欲しいか**: ユーザー視点での理想の姿
  - **解決状況**: 未着手/調査中/実装中/完了
```

---

## 未解決の問題

### Critical

- [ ] **spec-oracleは「仕様管理ツール」ではなく「グラフデータベースのCLI」になっている**
  - **発見日**: 2026-02-14
  - **詳細**: ドッグフーディングの結果、spec-oracleは仕様管理ツールとして機能していない。グラフデータベース（node/edge操作）のCLIになっている。ユーザーは「仕様を管理したい」のに、「nodeを追加してedgeで接続する」という作業を強いられる。
  - **現象**:
    - 仕様を追加したい → `add-node`, `add-edge`, UUID管理が必要
    - 仕様を確認したい → `list-nodes`で577個が表示され、把握不可能
    - 仕様を検索したい → `query`で結果が出るが、層の区別なく混在
    - 問題を見つけたい → `detect-contradictions`が重複を検出せず、`detect-omissions`が169個報告
  - **影響範囲**: ツール全体の存在意義。現状では実用不可能。
  - **どうあって欲しいか**:
    - 「パスワードは8文字以上」と入力すれば仕様として登録される
    - 「パスワード関連の仕様を見せて」と聞けば、関連仕様が階層的に表示される
    - 「問題をチェック」すれば、重要な問題だけが報告される
    - node/edge/UUIDといった内部概念を意識する必要がない
    - 仕様管理の本質（記述・検証・追跡）に集中できる
  - **解決状況**: 未着手

- [ ] **プロジェクトごとに仕様を分離できない（すべて一元管理）**
  - **発見日**: 2026-02-14
  - **詳細**: すべての仕様が`~/spec-oracle/specs.json`に一元管理される。プロジェクトごとに仕様を分離する仕組みがない。
  - **問題シナリオ**:
    - spec-oracleプロジェクトとztd-query-phpプロジェクトの仕様が同じファイルに混在
    - ztd-query-phpの仕様だけをGit管理したくてもできない
    - チームメンバーとztd-query-phpの仕様を共有したいが、spec-oracleの仕様も含まれてしまう
    - CIでztd-query-phpの仕様のみをチェックできない
    - プロジェクトをクローンしても仕様が含まれていない
  - **影響範囲**: チーム開発、CI/CD、バージョン管理が不可能。実プロジェクトで使えない。
  - **どうあって欲しいか**:
    - プロジェクトディレクトリ内（例：`.spec/`）に仕様データを保存したい
    - `spec init`でプロジェクトに仕様管理を導入できる
    - 仕様データをGitで管理し、チームで共有できる
    - CIで`spec check`を実行し、PR時に仕様の矛盾をチェックできる
    - プロジェクトをクローンすれば、仕様も一緒についてくる
    - 複数プロジェクトの仕様を同時に管理できる（プロジェクトごとに独立）
  - **解決状況**: 未着手

- [ ] **JSON形式の仕様データはマージ競合時に解決できない**
  - **発見日**: 2026-02-14
  - **詳細**: 仕様データが単一のJSONファイル（specs.json）で管理されているため、チーム開発でマージ競合が頻発し、解決が困難。
  - **シナリオ**:
    - 開発者Aが仕様Xを追加してPR作成
    - 開発者Bが仕様Yを追加してPR作成
    - 両方がnodes배列に要素を追加するため、マージ競合
    - JSONを手動編集して解決する必要がある（シンタックスエラーのリスク）
    - UUID、インデックス、エッジの参照が壊れる可能性
  - **影響範囲**: チーム開発が実質不可能。
  - **どうあって欲しいか**:
    - 仕様ごとに個別ファイルで管理（例：`.spec/nodes/constraint-001.yaml`）
    - マージ競合が起きにくい構造
    - 競合が起きても、ファイル単位で解決可能
    - または、`spec merge`コマンドで自動解決
    - Gitのマージツールが使える形式（YAML、TOMLなど）
  - **解決状況**: 未着手

- [ ] **JSON diffが読みにくく、仕様変更をレビューできない**
  - **発見日**: 2026-02-14
  - **詳細**: PRで仕様が変更されても、JSONのdiffは読みにくく、何が変わったのか理解できない。
  - **例**:
    ```diff
    +      {
    +        "id": "xxx-yyy-zzz",
    +        "content": "Password must be at least 8 characters",
    +        "kind": "Constraint",
    +        ...
    ```
    → 新しい仕様が追加されたことは分かるが、既存仕様との関係、影響範囲が不明
  - **影響範囲**: 仕様変更のレビューができない。コードレビューと同等の品質管理ができない。
  - **どうあって欲しいか**:
    - `spec diff main..feature-branch`コマンドで、人間が読める形式で差分を表示
    - 「仕様Xが追加されました」「仕様Yが削除されました」「仕様ZがAからBに関連付けられました」
    - PRのdiffも読みやすい形式（マークダウンなど）
    - GitHub上で仕様変更をレビューできる
  - **解決状況**: 未着手

- [ ] **CI/CDでspecdサーバーを起動・管理する方法が不明**
  - **発見日**: 2026-02-14
  - **詳細**: CI/CDで仕様チェックを実行したいが、specdサーバーの起動・管理方法が分からない。
  - **問題**:
    - `spec check`を実行するには、specdサーバーが起動している必要がある
    - CIでどうやってサーバーを起動する？バックグラウンドプロセス？
    - サーバーの起動完了をどう待つ？ヘルスチェック？
    - テスト後にサーバーをどう停止する？
    - 複数のCIジョブが同時実行されたら？ポート競合？
  - **影響範囲**: CI/CDでの自動チェックができない。
  - **どうあって欲しいか**:
    - `spec check`がサーバーなしで動作する（スタンドアロンモード）
    - または、`spec check --server-mode standalone`のようなオプション
    - CIでの使用例がドキュメント化されている（GitHub Actionsの設定例など）
    - サーバーの起動・停止を自動管理するラッパースクリプト
  - **解決状況**: 未着手

- [ ] **specコマンドが低レベルすぎて使えない（node/edgeの抽象化漏れ）**
  - **発見日**: 2026-02-14
  - **詳細**: 現在のspecコマンドは`add-node`, `list-nodes`, `add-edge`, `list-edges`など、完全にグラフデータベースの低レベルAPIを露出している。ユーザーは「nodeって何？」という状態で、仕様管理というユースケースが見えない。
  - **現状の問題**:
    - `spec add-node "パスワードは8文字以上" --kind constraint` ← ユーザーはkindを理解する必要がある
    - `spec add-edge <source-id> <target-id> --kind refines` ← UUIDとedge kindを管理する必要がある
    - 機能が多すぎて（30個以上のサブコマンド）何をすればいいか分からない
  - **あるべき姿**:
    - **ユースケース指向のコマンド**:
      - `spec add "パスワードは8文字以上"` → 内部でnode/kind/関係を推論
      - `spec check` → 矛盾と漏れを両方チェック
      - `spec find "認証"` → 関連仕様を検索
      - `spec trace "パスワード検証"` → その仕様の全層を表示
    - **低レベルAPIは別名前空間に**:
      - `spec api add-node ...`
      - `spec api add-edge ...`
      - 内部詳細が必要な場合のみ使用
  - **影響範囲**: ツール全体のユーザビリティ。現状では一般ユーザーが使えない。
  - **解決策案**:
    - specコマンドのサブコマンドを再設計
    - ユースケースベースのコマンド体系を構築
    - 低レベルAPIは`spec api`または`spec-admin`など別コマンドに分離
    - コマンド数を10個以下に削減
  - **解決状況**: 未着手

- [ ] **specコマンドが応答せず、直接JSON操作が必要**
  - **発見日**: 2026-02-14
  - **詳細**: `spec list-nodes`などのコマンドがバックグラウンドで実行されてしまい、直接結果を得られない。結果として、`~/spec-oracle/specs.json`を直接jqで解析する必要がある。
  - **再現手順**:
    1. `specd`サーバーを起動
    2. `./target/release/spec list-nodes`を実行
    3. コマンドがバックグラウンドタスクとして実行され、即座に結果が返らない
  - **影響範囲**: すべてのspecコマンドのCLI操作が困難。仕様の確認や問い合わせに支障。
  - **解決策案**:
    - gRPC接続の問題を調査（タイムアウト、ポート、アドレス設定）
    - `spec`コマンドの同期実行ロジックを確認
    - エラーハンドリングとログ出力の改善
  - **解決状況**: 未着手

- [ ] **U0層とU3層の間にformalizes/transformエッジが作成されていない**
  - **発見日**: 2026-02-14
  - **詳細**: 自然言語仕様（U0）と実行可能コード仕様（U3）は意味的に同じ要求を表現しているが、グラフ上で`formalizes`や`transform`エッジによって接続されていない。これにより、多層仕様の追跡と整合性検証ができない。
  - **具体例**:
    - U0: "Server must detect specification omissions" (id: b18aad55-5290-4327-8686-8b520987e204)
    - U3: "Invariant: omissions.iter().any(...)" (id: cd8cd613-be8b-4c83-a265-f441a113b3cb)
    - これらの間に関係性なし
  - **影響範囲**: 多層仕様管理の核心機能が機能していない。conversation.mdで議論されたU/D/A/fモデルのf（変換関数）が実装されていない。
  - **解決策案**:
    - `extract`コマンド実行時に、自動的にformalizes関係を推論・作成
    - `infer-relationships-ai`コマンドでformalizes関係も推論
    - 手動でformalizes関係を作成するUIコマンドを追加
  - **解決状況**: 未着手

- [x] **矛盾検出が重複仕様を検出しない** ✅ **解決済み (2026-02-14)**
  - **発見日**: 2026-02-14
  - **詳細**: `detect-contradictions`コマンドが「No contradictions detected」と報告するが、実際には同じドメインが2つずつ、同じInvariantが4つ以上存在している。
  - **解決策**:
    - ✅ 同一内容の重複を検出するロジックを追加 (session 32)
    - ✅ 意味的な矛盾を検出（password 8 vs 10 chars）(session 32)
    - ✅ false positive削減（53件→3件、94%削減）(session 33)
    - ✅ Synonym edgeで意図的な重複を除外 (session 32)
    - ✅ 層内のみで矛盾検出（層間の false positive回避）(session 32)
  - **結果**:
    - 重複検出: 動作確認済み（exact duplicate detection実装）
    - 矛盾検出: 3件の実際のpassword長矛盾を検出（precision 100%）
    - duplicate domains: Synonym edgeで管理されていることを確認
  - **関連コミット**: 3e50c49 "Enhance duplicate and semantic contradiction detection with precision"
  - **解決状況**: ✅ 完了

- [ ] **大量の重複仕様が存在する（データ品質問題）**
  - **発見日**: 2026-02-14
  - **詳細**: ドメイン、Invariant、Scenarioが大量に重複登録されている。
    - ドメイン: Architecture, Communication, Storage, Analysisが各2個
    - Invariant: 同じ内容が4個以上（例：`omissions.iter().any(|o| o.description.contains("Isolated"))`）
    - Scenario: 同じテストが2個以上
  - **影響範囲**: データの信頼性が低い。検索結果が冗長。
  - **解決策案**:
    - 重複データのクリーンアップスクリプト
    - extractコマンド実行時に既存仕様との重複チェック
    - マージ機能（重複仕様を統合）
  - **解決状況**: 未着手

- [ ] **コードと仕様の双方向同期ができない**
  - **発見日**: 2026-02-14
  - **詳細**: `extract`コマンドでコードから仕様を抽出できるが、一方向のみ。コードが変更されたら仕様を更新、仕様が変更されたらコードを更新、という双方向の同期ができない。
  - **問題シナリオ**:
    - コードからextractして仕様を生成
    - 手動で仕様を追加・修正
    - コードを修正
    - 再度extractすると、手動で追加した仕様と競合？上書き？マージ？
    - どちらが正なのか分からない（Single Source of Truthがない）
  - **影響範囲**: 仕様とコードが乖離する。どちらを信頼すべきか不明。
  - **どうあって欲しいか**:
    - コードと仕様のどちらが正か明確にしたい（または両方を正として扱う）
    - `spec sync`コマンドで、差分を検出し、マージ方法を提案
    - コードから自動生成された仕様には`auto-generated: true`タグ
    - 手動で追加した仕様は保護（extractで上書きされない）
    - 仕様をコードに逆変換（仕様からテストコード生成など）
  - **解決状況**: 未着手

- [ ] **仕様のライフサイクル管理ができない**
  - **発見日**: 2026-02-14
  - **詳細**: 仕様は追加されるだけで、更新・削除・アーカイブの仕組みがない。古い仕様が残り続け、データが肥大化する。
  - **問題**:
    - 577個の仕様があるが、どれが現在有効なのか不明
    - 実装が変更されても、古い仕様が残っている
    - 削除すべき仕様が分からない（参照されているか不明）
    - アーカイブ（無効化するが履歴として残す）の仕組みがない
    - 仕様のバージョン管理ができない
  - **影響範囲**: 仕様の信頼性が低下。メンテナンス不可能。
  - **どうあって欲しいか**:
    - 仕様に`status: active|deprecated|archived`のようなステータス
    - `spec deprecate <id>`で仕様を非推奨にできる
    - `spec archive <id>`で仕様をアーカイブできる
    - `spec list --status active`でアクティブな仕様のみ表示
    - 参照されていない仕様を検出（`spec find-unused`）
    - 仕様の最終更新日・最終参照日を記録
  - **解決状況**: 未着手

- [ ] **kindの使い分け基準が不明確**
  - **発見日**: 2026-02-14
  - **詳細**: 仕様を追加する際、`--kind`で種類を指定する必要があるが、どのkindを選ぶべきか判断できない。
  - **現状のkind**:
    - assertion: 「具体的な挙動の主張」？
    - constraint: 「普遍的な不変条件」？
    - scenario: 「存在要求（必要なパス）」？
    - definition: 「用語の定義」？
    - domain: 「ドメイン境界宣言」？
  - **問題の例**:
    - 「パスワードは8文字以上」は constraint？ assertion？
    - 「ユーザーがログインできる」は scenario？ assertion？
    - 「レスポンスタイムは1秒以内」は constraint？ assertion？
    - kind間の境界が曖昧で、一貫性のない分類になる
  - **影響範囲**: ユーザーが仕様を追加できない。間違ったkindで登録され、検索・分類が機能しない。
  - **どうあって欲しいか**:
    - kindを選ばなくても仕様を追加できる（自動推論）
    - または、具体例とガイドラインを提示
    - 「これは〜という意味なので、constraintが適切です」と説明
    - kindが間違っていたら、後から変更できる
    - kindによる振る舞いの違いが明確（検証方法、表示形式など）
  - **解決状況**: 未着手

- [ ] **古い仕様を識別できない**
  - **発見日**: 2026-02-14
  - **詳細**: 仕様には`created_at`があるが、「この仕様は古くて無効」「これは最新でアクティブ」という区別ができない。
  - **問題シナリオ**:
    - 「パスワードは8文字以上」という仕様を追加（2024年）
    - 要件が変わって「パスワードは10文字以上」に変更（2025年）
    - 両方の仕様が残っているが、どちらが有効か不明
    - `created_at`で判断？でも、古い仕様を参考に残したい場合もある
    - 「古いが参考として残す」と「古いので無効」の区別がない
  - **影響範囲**: 矛盾する仕様が並存し、どちらを信頼すべきか分からない。
  - **どうあって欲しいか**:
    - 仕様に「バージョン」の概念
    - 「パスワード長要件 v1」「パスワード長要件 v2」のように管理
    - 最新バージョンが明確（`spec list --latest-only`）
    - 古いバージョンは履歴として参照可能（`spec history <id>`）
    - 仕様を更新したら、自動的にバージョンアップ
  - **解決状況**: 未着手

- [ ] **仕様の変更履歴・バージョン管理がない**
  - **発見日**: 2026-02-14
  - **詳細**: 仕様を変更する際、上書きするのか、新規追加するのか不明。変更履歴が残らない。
  - **問題**:
    - 仕様を更新する方法が分からない（`add-node`で新規追加？`update-node`は存在しない？）
    - 実際には新規ノードとして追加されるため、古い仕様が残り続ける（重複の原因）
    - なぜ仕様が変更されたのか、変更履歴が分からない
    - 「いつ、誰が、なぜ、どう変更したか」の記録がない
    - 仕様の変更をレビュー・承認するプロセスがない
  - **影響範囲**: 仕様の信頼性、変更管理、監査が不可能。
  - **どうあって欲しいか**:
    - ~~`spec update <id>`で仕様を更新~~（※どのIDを指定すべきか判断できない問題あり）
    - 仕様追加時に重複を自動検出し、置き換えるか確認（`spec add "..." → 類似仕様を検出 → 置き換えますか？`）
    - または、仕様に名前を付けて管理（`spec define password-length "10文字以上"`で自動的に古いバージョンを置き換え）
    - 変更理由をコミットメッセージのように記録
    - `spec history <name>`で変更履歴を表示
    - `spec diff v1..v2`でバージョン間の差分を表示
    - 変更のロールバック（`spec revert <name> v1`）
  - **解決状況**: 未着手

- [ ] **仕様の「更新」をどう判断するか不明確**
  - **発見日**: 2026-02-14
  - **詳細**: `spec update`のような更新コマンドを実装しようとしても、「どれを更新すべきか」「更新なのか新規なのか」を判断できない。
  - **問題の具体例**:
    - 「パスワードは8文字以上」→「パスワードは10文字以上」に変更したい
    - しかし、`query "password"`で13個の仕様がヒット
    - どのUUIDが更新対象なのか判断できない
    - そもそもこれは「更新」なのか「新しい要件の追加」なのか？
    - 仕様のアイデンティティは何で決まるのか？（内容？UUID？意味？）
  - **システム側の判断も困難**:
    - 「これは既存仕様の更新だ」と自動判定できない
    - 意味的に同じ仕様かどうかをAIで判定？（確実ではない）
    - 明示的に指定しても、ユーザーが正しいIDを選べない
  - **影響範囲**: 仕様の更新ワークフローが設計できない。
  - **どうあって欲しいか**:
    - **仕様に人間が読める名前/スラグを付ける**（`password-length-requirement`など）
    - 名前で仕様を参照・更新できる（`spec define password-length "10文字以上"`）
    - 同じ名前で再定義すると自動的にバージョンアップ
    - または、追加時に類似仕様を検出し、インタラクティブに確認
      ```
      spec add "パスワードは10文字以上"
      → 類似の仕様が見つかりました:
         [1] パスワードは8文字以上 (created: 2024-01-01)
         置き換えますか？(y/n/新規追加)
      ```
    - UUIDではなく、意味のある識別子で仕様を管理
  - **解決状況**: 未着手

### High

- [ ] **U1層（形式仕様）とU2層（インターフェース定義）の仕様が欠落**
  - **発見日**: 2026-02-14
  - **詳細**: 主要な仕様（omission検出など）について、U0（自然言語）とU3（コード）の間の中間層が記録されていない。
    - U1: TLA+、Alloy、形式モデルなど
    - U2: gRPC proto定義、API仕様、型定義など
  - **影響範囲**: 完全な多層仕様追跡ができない。設計から実装への変換過程が不可視。
  - **解決策案**:
    - protoファイルからU2層仕様を抽出する機能を追加
    - 手動でU1/U2層仕様を登録できるコマンドを追加
    - formality_layerの自動推論を改善
  - **解決状況**: 未着手

- [ ] **formality_layerの二重管理**
  - **発見日**: 2026-02-14
  - **詳細**: ノード構造の`formality_layer`フィールドと`metadata.formality_layer`が両方存在し、実際の層情報はmetadataに文字列として記録されている。ノード自体のformality_layerは常に0のまま。
  - **影響範囲**: データモデルの一貫性がない。クエリが複雑になる。
  - **解決策案**:
    - `formality_layer`フィールドを正しく更新するようにextractorを修正
    - または、metadataのみを使用し、ノードフィールドを削除
    - データマイグレーションスクリプトを作成
  - **解決状況**: 未着手

- [ ] **list-nodesが大量の結果を一気に表示する**
  - **発見日**: 2026-02-14
  - **詳細**: `spec list-nodes`を実行すると577個のノードが一気に表示される。多すぎて把握できない。
  - **影響範囲**: プロジェクトの仕様全体を把握できない。
  - **解決策案**:
    - デフォルトで要約表示（ドメインごとの件数など）
    - ページネーション（`--limit`, `--offset`）
    - インタラクティブモード（fzfのような選択UI）
    - `spec summary`コマンドで概要を表示
  - **解決状況**: 未着手

- [ ] **検索結果に層情報が表示されない**
  - **発見日**: 2026-02-14
  - **詳細**: `spec query "omission"`で24件ヒットするが、自然言語仕様（U0）とコード仕様（U3）が混在していて区別できない。
  - **影響範囲**: どの層の仕様か分からず、混乱する。
  - **解決策案**:
    - 出力に`[U0]`, `[U3]`などの層ラベルを追加
    - `--layer <N>`オプションで層を絞り込み
    - 層ごとにグループ化して表示
  - **解決状況**: 未着手

- [ ] **get-nodeの出力情報が少なすぎる**
  - **発見日**: 2026-02-14
  - **詳細**: `spec get-node <id>`がContentとKindしか表示しない。formality_layer、metadata、関連ノード、作成日時などが見えない。
  - **影響範囲**: ノードの詳細情報を得られない。
  - **解決策案**:
    - 全フィールドを表示（layer, metadata, timestamps）
    - 関連ノードも一緒に表示（incoming/outgoing edges）
    - `--verbose`フラグで詳細表示
  - **解決状況**: 未着手

- [ ] **list-edgesがUUIDしか表示せず、内容が分からない**
  - **発見日**: 2026-02-14
  - **詳細**: `spec list-edges --node <id>`でエッジが表示されるが、UUIDのみで、ノードの内容が分からない。
  - **再現手順**:
    1. `spec list-edges --node b18aad55-5290-4327-8686-8b520987e204`
    2. `bf71989b... --[refines]--> b18aad55...`と表示される
    3. UUIDだけでは何のノードか分からない
  - **影響範囲**: エッジを理解するために、各UUIDで`get-node`を実行する必要がある。
  - **解決策案**:
    - ノードの内容も一緒に表示
    - `[scenario] System identifies isolated nodes --[refines]--> [constraint] Server must detect omissions`
  - **解決状況**: 未着手

- [ ] **関連仕様を階層的に表示するコマンドがない**
  - **発見日**: 2026-02-14
  - **詳細**: 特定の仕様に関連する全ノード（refines, formalizes関係）を一度に見るコマンドがない。UUIDごとに`get-node`を何度も実行する必要がある。
  - **影響範囲**: 仕様の全体像を把握するのに時間がかかる。
  - **解決策案**:
    - `spec trace <id>`コマンド（関連ノードをツリー表示）
    - `spec show <id> --with-related`（詳細+関連ノード）
  - **解決状況**: 未着手

- [ ] **仕様追加時に既存仕様との関係が自動作成されない**
  - **発見日**: 2026-02-14
  - **詳細**: `add-node`で仕様を追加しても、関連する既存仕様との関係が作成されない。ドメインへの関連付けもない。
  - **再現手順**:
    1. `spec add-node "Passwords must contain alphanumeric characters" --kind constraint`
    2. 既存のパスワード関連仕様が13個あるが、関係が作成されない
  - **影響範囲**: 追加した仕様が孤立する。手動でエッジを作成するのは困難。
  - **解決策案**:
    - 追加時に類似仕様を検索し、関係を提案
    - ドメインを自動推論
    - `--relate-to <domain>`オプション
  - **解決状況**: 未着手

- [ ] **新規仕様の関連付けが困難（UUIDから選べない）**
  - **発見日**: 2026-02-14
  - **詳細**: 追加した仕様を既存仕様と関連付けたいが、13個のUUIDから適切なものを選ぶのは不可能。
  - **影響範囲**: 仕様間の関係を正しく構築できない。
  - **解決策案**:
    - インタラクティブな関連付けUI（候補を表示して選択）
    - `spec relate <new-spec-id>`で関連候補を提案
  - **解決状況**: 未着手

- [ ] **新規追加ノードが関係推論の対象にならない**
  - **発見日**: 2026-02-14
  - **詳細**: `add-node`で仕様を追加した後、`infer-relationships`を実行しても、新しいノードに関係が作成されない。
  - **再現手順**:
    1. `spec add-node "Passwords must contain alphanumeric characters" --kind constraint`
    2. `spec infer-relationships`
    3. `spec list-edges --node <new-id>` → "No edges found"
  - **影響範囲**: 新規仕様が常に孤立する。
  - **解決策案**:
    - infer-relationshipsのロジック修正（全ノードを対象にする）
    - 追加直後に自動的に関係推論を実行
  - **解決状況**: 未着手

- [x] **パスワード仕様に矛盾がある（データ品質問題）** ✅ **検出済み (2026-02-14)**
  - **発見日**: 2026-02-14
  - **詳細**: パスワード長の仕様が矛盾している：
    - "Password must be at least 8 characters" (77ad7450...)
    - "Password must be at least 8 characters" (34bf0b12...)
    - "Password must be minimum 10 characters" (5237d0e8...)
    - "Password must be at least 8 characters long" (5fdeafb2...)
  - **検出結果**: `detect-contradictions`で3件の矛盾として正しく検出される
  - **次のステップ**: データクリーンアップ（8文字 or 10文字に統一するか決定）
  - **関連コミット**: 3e50c49 "Enhance duplicate and semantic contradiction detection with precision"
  - **解決状況**: ✅ 検出機能は完了、データ修正は未着手

- [ ] **仕様からドキュメントを生成・可視化できない**
  - **発見日**: 2026-02-14
  - **詳細**: 仕様を記述しても、人間が読めるドキュメントや可視化ができない。仕様はグラフデータベースの中に閉じ込められている。
  - **欲しい機能**:
    - 仕様からMarkdown/HTMLドキュメントを生成
    - 仕様の関係図を可視化（グラフ、ツリー、マインドマップ）
    - 層ごとに整理されたドキュメント（U0: 要求仕様、U3: 実装仕様）
    - ドメインごとのサマリー
    - 仕様のタイムライン（いつ追加されたか）
  - **影響範囲**: 仕様を記述しても、共有・レビュー・理解が困難。
  - **どうあって欲しいか**:
    - `spec docs generate`でドキュメント生成
    - `spec visualize <id>`で関連仕様を図示
    - 静的サイト生成（GitHub Pagesで公開）
    - PDFエクスポート（ステークホルダーと共有）
  - **解決状況**: 未着手

- [ ] **仕様の検索・探索機能が貧弱**
  - **発見日**: 2026-02-14
  - **詳細**: `query`コマンドはキーワード検索のみ。自然言語での質問、ファセット検索、高度なフィルタリングができない。
  - **現状の問題**:
    - `query "password"`は24件ヒットするが、どれが欲しい仕様か分からない
    - 「パスワードの長さに関する制約」のような自然言語で検索できない
    - 「U0層のパスワード関連の制約」のような複合条件で絞り込めない
    - 検索結果のランキング、関連度が不明
  - **影響範囲**: 仕様が増えると、欲しい仕様を見つけられない。
  - **どうあって欲しいか**:
    - 自然言語検索（「パスワードの長さ制約は？」）
    - ファセット検索（層、ドメイン、種類、日付で絞り込み）
    - インクリメンタル検索（入力しながら候補を表示）
    - 検索結果のランキング（関連度順）
    - `spec find --layer 0 --domain authentication --kind constraint`
  - **解決状況**: 未着手

### Medium

- [ ] **漏れ検出が過剰報告する（169個）**
  - **発見日**: 2026-02-14
  - **詳細**: `spec detect-omissions`が169個の漏れを報告するが、多すぎて対処できない。また、明らかに関連している仕様（"Passwords must be at least 8 characters"と"Invariant: password.len() >= 8"）が孤立として報告される。
  - **影響範囲**: 漏れ検出が実用的でない。
  - **解決策案**:
    - 重要度スコアリング（優先度の高い漏れを先に表示）
    - `--critical-only`フラグ（重大な漏れのみ）
    - 関係推論の改善（意味的に関連する仕様を自動接続）
  - **解決状況**: 未着手

- [ ] **infer-relationshipsが大量のエッジを一度に作成**
  - **発見日**: 2026-02-14
  - **詳細**: `spec infer-relationships`を実行すると、2,192個のエッジが一度に作成される。正しいか検証できない。また、424個のレビュー提案も多すぎる。
  - **影響範囲**: データの信頼性が不明。誤った関係が大量に作成される可能性。
  - **解決策案**:
    - バッチ実行ではなく、インタラクティブモード（1つずつ確認）
    - confidenceの閾値を上げる
    - ドライランモード（`--dry-run`で結果をプレビュー）
    - `--limit <N>`オプション（N個までに制限）
  - **解決状況**: 未着手

- [ ] **推論結果に循環参照がある**
  - **発見日**: 2026-02-14
  - **詳細**: `infer-relationships`の提案に循環参照が含まれる：
    - "A --Refines-> B" と "B --Refines-> A" が同時に提案される
  - **影響範囲**: グラフの一貫性が失われる。矛盾が生まれる。
  - **解決策案**:
    - 循環参照チェックを追加
    - 双方向のrefines関係を禁止
    - confidenceの高い方だけを採用
  - **解決状況**: 未着手

- [ ] **specコマンドのレスポンスが遅い/タイムアウトする**
  - **発見日**: 2026-02-14
  - **詳細**: `spec list-edges --node <id>`などのコマンドが完了しない。
  - **影響範囲**: 仕様の探索とデバッグが困難。
  - **解決策案**: gRPCのタイムアウト設定、サーバー側のパフォーマンス最適化
  - **解決状況**: 未着手

- [ ] **CLIの出力フォーマットが人間に読みにくい**
  - **発見日**: 2026-02-14
  - **詳細**: 仕様の内容を確認するために、結局jqで整形する必要がある。CLIの出力が構造化されていない、または読みにくい。
  - **影響範囲**: ユーザビリティ
  - **解決策案**:
    - 表形式出力（tableフォーマット）を追加
    - `--format json|table|tree`オプションを追加
    - デフォルトで人間が読みやすい形式にする
  - **解決状況**: 未着手

- [ ] **仕様の多層構造を可視化するコマンドがない**
  - **発見日**: 2026-02-14
  - **詳細**: 特定の仕様（例：omission検出）のU0からU3までの全層を一覧表示するコマンドがない。
  - **影響範囲**: 多層仕様の理解が困難。
  - **解決策案**:
    - `spec trace <node-id>`コマンドを追加（formalizes/transform関係を辿って全層を表示）
    - `spec layers <query>`コマンドで、特定トピックの全層仕様を表示
  - **解決状況**: 未着手

### Low

- [ ] **READMEとCLIヘルプの情報が不足**
  - **発見日**: 2026-02-14
  - **詳細**: 多層仕様管理の使い方、formality_layerの意味、formalizes/transform関係の説明が不足。
  - **影響範囲**: ユーザーが機能を理解できない
  - **解決策案**: ドキュメント整備、チュートリアル追加
  - **解決状況**: 未着手

---

## 解決済みの問題

（まだありません）

---

## アーカイブ

（古い解決済み問題をここに移動します）
