\documentclass[11pt]{article}
\usepackage[a4paper,margin=25mm]{geometry}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{hyperref}
\usepackage{enumitem}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}

\title{Dual Semantics for Root-Spec Control in UAD/f:\
Join ($U0$) and Meet ($U^{\wedge}$) in a Typed Core}
\author{spec-oracle project}
\date{February 14, 2026}

\begin{document}
\maketitle

\begin{abstract}
We address definitional ambiguity in layered root-spec reconstruction for UAD/f.
The common notation
$U0=\bigcup_i f^{-1}_{0i}(A_i)$
often leaves three points implicit: typed layer spaces, partiality of projection,
and the semantic role of the operator itself.
We give a typed core model with root space $\Omega$, index set $I$,
layer carriers $\beta_i$, domain/admissible predicates
$D_i\subseteq \beta_i$, $A_i\subseteq D_i$, and partial projections
$\mathrm{proj}_i: \Omega \to \mathrm{Option}\,\beta_i$.
Inverse image is induced from projection witnesses, not postulated.

A central revision is to separate two operators in one model:
(1) join-style coverage $U0:=\bigcup_i lifted(i)$ and
(2) meet-style integration $U^{\wedge}$ requiring all active layers.
We prove: GLB characterization of $U^{\wedge}$,
$U^{\wedge}\subseteq U0$ under non-empty active sets,
a transfer theorem with explicit same-root coupling assumptions,
inter-layer composition via partial bind,
one-sided extraction adequacy (sound-only and complete-only inclusions),
and a mechanized non-adjunction result under undefined projection points.

An OSS extraction proof-of-concept is performed on three artifacts
(PostgreSQL, zlib, SQLite) with automated extraction,
source-lock metadata (URL/SHA256/timestamp), and mutation sensitivity checks.
The contribution is a mechanization paper that exposes hidden assumptions
and provides reproducible proof and extraction artifacts.
\end{abstract}

\section{Problem Statement and Objectives}
\textbf{Problem.}
The core problem is multi-layer control failure:
requirements, API specs, types/contracts, tests, and implementations each provide
local guarantees, but cross-layer consistency is not controlled by a shared ruler.
Here, a ``layer'' means a specification artifact at a different abstraction level.
Each layer $i$ is connected from root space $\Omega$ via partial projection
$\mathrm{proj}_i:\Omega\to\mathrm{Option}\,\beta_i$.
This causes layer contradictions, coverage gaps, and broken change propagation.

\textbf{Objective.}
Formalize a minimal typed kernel for cross-layer control, separate
join-style coverage ($U0$) from meet-style simultaneous satisfaction ($U^{\wedge}$),
and mechanically validate transfer/composition/adequacy assumptions.

\textbf{Scope.}
The result is a reusable mechanized kernel with explicit assumptions,
plus reproducible extraction evidence on real artifacts.

\section{Research Questions}
\begin{enumerate}[leftmargin=2em]
\item[\textbf{RQ1}] Can induced inverse images be defined coherently with per-layer heterogeneous carriers?
\item[\textbf{RQ2}] Can $A_i\subseteq D_i$ be lifted to root-witness validity?
\item[\textbf{RQ3}] Can join-style and meet-style root operators coexist coherently in one typed model?
\item[\textbf{RQ4}] Can transfer/composition assumptions be stated precisely enough for machine checking?
\item[\textbf{RQ5 (theory)}] Can extraction adequacy over an abstract relation $E$ be decomposed into sound-only and complete-only forms?
\item[\textbf{RQ6 (practice)}] Can technical re-executability of the real-OSS extraction pipeline be ensured?
\end{enumerate}

\section{Typed UAD/f Core}
\begin{definition}[Typed model]
Fix root space $\Omega$, index set $I$, and carrier family $\beta_i$.
For each layer $i$:
\[
D_i\subseteq\beta_i,\quad A_i\subseteq D_i,\quad
\mathrm{proj}_i:\Omega\to\mathrm{Option}\,\beta_i.
\]
\end{definition}
\noindent
Separating $D_i$ from $A_i$ is intentional: $D_i$ captures the addressed domain,
while $A_i$ captures admissible behavior inside that domain.
This separation enables root-level witness-within-domain theorems (RQ2).

\begin{definition}[Induced inverse image]
For $S\subseteq\beta_i$:
\[
f^{-1}_{0i}(S)
:=\{x\in\Omega\mid\exists y\in\beta_i,\ \mathrm{proj}_i(x)=\mathrm{some}(y)\land y\in S\}.
\]
\end{definition}

\paragraph{Lean excerpt (definition level).}
\begin{verbatim}
def preimage (M : Model ι α) (i : ι) (S : SpecSet (M.carrier i)) : SpecSet α :=
  fun x => ∃ y : M.carrier i, M.proj i x = some y ∧ y ∈ S

def UAndOn (active : ι → Prop) : SpecSet α :=
  fun x : α => ∀ i : ι, active i → x ∈ M.lifted i
\end{verbatim}

\paragraph{Order used for theorem terminology.}
All terms join/meet/LUB/GLB in this paper are with respect to set inclusion
order ($\subseteq$):
\begin{itemize}
\item join (least upper bound) $=\cup$;
\item meet (greatest lower bound) $=\cap$.
\end{itemize}
Specification strength is discussed only as an intuition: larger admissible sets
are weaker specifications. Thus $U0$ is an over-approximation/coverage operator.

\section{Join/Meet Split for Root Semantics}
\begin{definition}[Join-style root coverage]
\[
lifted(i):=f^{-1}_{0i}(A_i),\qquad U0:=\bigcup_{i\in I} lifted(i).
\]
$U0$ is coverage/join in set-inclusion order:
at least one active layer admits the root witness.
$U0$ is therefore an over-approximation (weaker, in the admissible-set sense).
\end{definition}

\begin{definition}[Meet-style integrated root]
For active-layer predicate $active:I\to Prop$:
\[
U^{\wedge}_{active}(x):\equiv \forall i,\ active(i)\to x\in lifted(i).
\]
Global meet is $U^{\wedge}:=U^{\wedge}_{\top}$.
\end{definition}

\begin{theorem}[Join/meet linkage]
\label{thm:join-meet-linkage}
If at least one active layer exists, then
$U^{\wedge}_{active}\subseteq U0_{active}$.
For two layers $i,j$, consistency is equivalent to non-emptiness of
$U^{\wedge}_{\{i,j\}}$.
\end{theorem}

\begin{theorem}[Active-set antitonicity]
If $active\subseteq active'$, then
$U^{\wedge}_{active'}\subseteq U^{\wedge}_{active}$.
With empty active set, $U^{\wedge}$ is vacuously universal.
\end{theorem}

\section{Core Theorems}
\begin{theorem}[Transfer with same-root coupling]
\label{thm:transfer}
Let $R: \beta_i\to\beta_j\to Prop$ satisfy:
(1) $\forall x,y_j,\ \mathrm{proj}_j(x)=some(y_j) \to \exists y_i,\ \mathrm{proj}_i(x)=some(y_i)\land R(y_i,y_j)$,
(2) $R$ preserves admissibility from $A_j$ to $A_i$.
Then $lifted(j)\subseteq lifted(i)$.
\end{theorem}
\noindent
This theorem provides a sufficient condition; necessity is not claimed.

\begin{theorem}[Composition law]
\label{thm:composition}
For $g: \beta_i\to Option\,\beta_j$,
if $\mathrm{proj}_j=\mathrm{bind}(\mathrm{proj}_i,g)$ pointwise,
then
\[
f^{-1}_{0j}(S)=f^{-1}_{0i}(pullbackVia_g(S)),
\]
where
$pullbackVia_g(S):=\{y_i\mid\exists y_j, g(y_i)=some(y_j)\land y_j\in S\}$.
\end{theorem}

\begin{theorem}[One-sided adequacy decomposition]
\label{thm:adequacy}
For extraction relation $E: \Omega\to\beta_i\to Prop$:
\begin{itemize}
\item if projection implies $E$ (soundness), then $preimage\subseteq semanticPullback$;
\item if $E$ implies projection realizability (completeness), then $semanticPullback\subseteq preimage$;
\item if both hold, equality follows.
\end{itemize}
Here, $E$ is an abstract relation; this theorem does not prove semantic preservation of the regex extractor used in the OSS demo.
Operationally:
\begin{itemize}
\item completeness-side inclusion is required for safe emptiness claims (avoid false contradictions);
\item soundness-side inclusion is required to avoid reporting spurious satisfiable witnesses.
\end{itemize}
\end{theorem}

\begin{theorem}[Non-adjunction under partiality]
\label{thm:no-adjunction}
If $\exists x_0,\ \mathrm{proj}_i(x_0)=none$, then existential preimage at layer $i$
has no left adjoint on full powersets.
\end{theorem}

\paragraph{Foundational lemmas (background).}
Preimage monotonicity, preimage union preservation,
$U0$ least-upper-bound characterization,
and contradiction/consistency duality are mechanized as background results.

\section{Formalization Engineering Decisions}
The main contribution is a reference mechanization that makes required assumptions explicit:
these items are presented as implementable design decisions in the UAD/f context,
not as claims of first discovery in the broader formal-methods literature.
\begin{enumerate}[leftmargin=2em]
\item ``Integration'' is semantically split (join vs meet) and cannot be represented by a single operator name.
\item Transfer requires same-root coupling assumptions; relation-only statements are insufficient.
\item Adequacy assumptions must be staged (sound-only / complete-only) before bi-implication claims.
\item Partial projections break automatic adjunction intuition.
\end{enumerate}

\section{Case Study and Extraction Pipeline Executability Demo}
\paragraph{Lean-level case theorem.}
In \texttt{PasswordPolicy.lean}, we prove:
\[
check=true \iff \exists n,\ n\in lifted(req)\cap lifted(api)\cap lifted(code).
\]
This is a theorem-level equivalence between closed-form check and witness existence.

\paragraph{Real OSS extraction.}
\texttt{paper/case-study/real\_projects/external\_validation.py}
fetches official pages and extracts numeric bounds for
PostgreSQL identifier length, zlib compression level, and SQLite page size.
\textbf{Important:} this is a technical executability demo ($n=3$ convenience sample),
not an estimation of contradiction prevalence or population representativeness.
Observed results (2026-02-14):
\begin{itemize}
\item projects: 3, consistent: 3, contradictory: 0
\item mutation sensitivity: 3/3 contradictory mutations detected
\end{itemize}
\noindent
Selection note: the three projects form a convenience sample chosen for
public availability of requirement/API/code artifacts and stable URL retrieval.
Hence this section demonstrates pipeline executability with reproducibility locks, not contradiction prevalence estimation.
\noindent
Constraint domains are intentionally diverse (identifier length, compression level, page size)
to test extraction feasibility across different numeric-spec contexts.
\noindent
Mutation checks validate contradiction-detection mechanics only; they are not evidence of real-world defect rates.
\noindent
Theory linkage is intentionally limited: extracted bounds are treated as
operational input candidates for interval checks.
Extraction soundness/completeness itself is not proven in this paper,
and we do not claim direct theorem application from this regex layer.
\noindent
Thus the regex extraction layer is treated as an input-construction layer, not as a verified extractor.
This section addresses RQ6 (practice), while practical application of RQ5 (theory)
requires additional extractor-semantics proofs.

\paragraph{Reproducibility lock.}
The pipeline outputs:
\begin{itemize}
\item \texttt{external\_validation\_results.json}
\item \texttt{external\_validation\_sources.lock.json}
\item \texttt{snapshots/*}
\end{itemize}
with URL, SHA256, retrieval timestamp, and snapshot path.
The extraction script uses Python standard library only (no extra pip dependencies).
Snapshots are included in this repository for offline replay.
Online fetching requires network access.
Offline replay is supported via:
\begin{verbatim}
python external_validation.py --offline-lock external_validation_sources.lock.json
\end{verbatim}
which validates snapshot SHA256 against lock records and re-runs extraction without network.

\section{Reproducibility and Transparency}
Lean reproduction:
\begin{verbatim}
cd paper/lean
~/.elan/bin/lake build
\end{verbatim}

Toolchain:
\begin{itemize}
\item Lean4: \texttt{leanprover/lean4:v4.27.0}
\item Lake: \texttt{5.0.0-src+db93fe1}
\item manifest: \texttt{packages = []} (Lean stdlib only; no mathlib)
\end{itemize}

Logic assumptions:
\texttt{SpecSet := (\_ -> Prop)} with extensionality via
\texttt{funext + propext}; no explicit \texttt{open Classical} import in this development.

Current size:
\begin{itemize}
\item 1103 LOC
\item 43 theorem declarations
\item theorem breakdown: 12 core theorem claims (\S4), 26 background/proof-support lemmas, 5 example theorems
\end{itemize}

\section{Related Work Positioning}
We align with abstract-interpretation intuition on monotone inverse-image behavior
(Cousot \& Cousot), but differ by first-class partiality and typed per-layer carriers.
Institution theory (Goguen \& Burstall) motivates cross-language satisfaction transfer,
while this paper focuses on a concrete root operator pair ($U0$, $U^{\wedge}$)
and mechanized obligations (transfer/composition assumptions).
The tradeoff is explicit: we prioritize executability in Lean with
first-class partial projections and root-space join/meet operators over full categorical generality.
Compared with system-level formalisms such as TLA+,
this work isolates the integration kernel rather than full behavioral modeling.
Interface-automata style assume/guarantee compatibility (de Alfaro \& Henzinger)
is complementary: we do not replace interface-theoretic composition,
but make root-level operator semantics explicit under partial projections.
Refinement-calculus viewpoints (Back \& von Wright) provide a general
stepwise-development framework; our focus is narrower on mechanizing
root operators with explicit order semantics.
Practical use guideline:
\begin{itemize}
\item use this UAD/f core when root-level join/meet separation under partial projections is the primary concern;
\item use Institution-style frameworks when cross-logic satisfaction transport is central;
\item use TLA+ when temporal behavior/refinement is the core objective.
\end{itemize}

\section{Scope and Limitations}
\begin{enumerate}[leftmargin=2em]
\item No full semantic correctness proof of concrete industrial extractors.
\item External evidence is limited to a convenience sample of three projects and numeric-bound constraints.
\item Mutation checks validate detector sensitivity, not real-world bug prevalence.
\item Regex extraction soundness/completeness is not quantified here.
\item Current external cases do not yet exercise deep composition chains or one-sided adequacy in production extractors.
\end{enumerate}

\section{Conclusion}
We provide a typed, mechanized UAD/f root-integration core that explicitly separates
join-style coverage ($U0$) from meet-style simultaneous satisfaction ($U^{\wedge}$).
The main contribution is explicit exposure and machine-checking of
previously implicit assumptions (operator semantics, transfer coupling,
one-sided adequacy, and partiality-induced non-adjunction),
plus reproducible source-locked execution of the pre-input extraction pipeline.
RQ closure (navigation): RQ1 is resolved by the typed inverse-image definition;
RQ2 by domain-lift witness lemmas; RQ3 by join/meet split plus Theorem~\ref{thm:join-meet-linkage};
RQ4 by Theorem~\ref{thm:transfer} and Theorem~\ref{thm:composition};
RQ5 (theory) by Theorem~\ref{thm:adequacy}; RQ6 (practice) is resolved as technical
re-executability of the source-locked extraction pipeline.
Extractor soundness/completeness is outside RQ6 scope and left as future work.

\paragraph{References}
[1] Patrick Cousot and Radhia Cousot, ``Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints,'' in \emph{Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL 1977)}, pp. 238--252, 1977.\\
[2] Joseph A. Goguen and Rod M. Burstall, ``Introducing Institutions,'' in \emph{Logics of Programs}, Lecture Notes in Computer Science 164, Springer, pp. 221--256, 1984.\\
[3] Leslie Lamport, \emph{Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers}, Addison-Wesley, 2002.\\
[4] Luca de Alfaro and Thomas A. Henzinger, ``Interface Automata,'' in \emph{Proceedings of the 9th ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE 2001)}, pp. 109--120, 2001.\\
[5] Ralph-Johan Back and Joakim von Wright, \emph{Refinement Calculus: A Systematic Introduction}, Springer, 1998.

\end{document}
